
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>sleap.io.dataset &#8212; SLEAP  documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for sleap.io.dataset</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A SLEAP dataset collects labeled video frames.</span>

<span class="sd">This contains labeled frame data (user annotations and/or predictions),</span>
<span class="sd">together with all the other data that is saved for a SLEAP project</span>
<span class="sd">(videos, skeletons, negative training sample anchors, etc.).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">zipfile</span>
<span class="kn">import</span> <span class="nn">atexit</span>

<span class="kn">import</span> <span class="nn">attr</span>
<span class="kn">import</span> <span class="nn">cattr</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
<span class="kn">import</span> <span class="nn">h5py</span> <span class="k">as</span> <span class="nn">h5</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">MutableSequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Text</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">ForwardRef</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">_ForwardRef</span> <span class="k">as</span> <span class="n">ForwardRef</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">sleap.skeleton</span> <span class="kn">import</span> <span class="n">Skeleton</span><span class="p">,</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">sleap.instance</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Instance</span><span class="p">,</span>
    <span class="n">Point</span><span class="p">,</span>
    <span class="n">LabeledFrame</span><span class="p">,</span>
    <span class="n">Track</span><span class="p">,</span>
    <span class="n">PredictedPoint</span><span class="p">,</span>
    <span class="n">PredictedInstance</span><span class="p">,</span>
    <span class="n">make_instance_cattr</span><span class="p">,</span>
    <span class="n">PointArray</span><span class="p">,</span>
    <span class="n">PredictedPointArray</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">sleap.io</span> <span class="kn">import</span> <span class="n">pathutils</span>
<span class="kn">from</span> <span class="nn">sleap.io.legacy</span> <span class="kn">import</span> <span class="n">load_labels_json_old</span>
<span class="kn">from</span> <span class="nn">sleap.io.video</span> <span class="kn">import</span> <span class="n">Video</span>
<span class="kn">from</span> <span class="nn">sleap.gui.suggestions</span> <span class="kn">import</span> <span class="n">SuggestionFrame</span>
<span class="kn">from</span> <span class="nn">sleap.gui.missingfiles</span> <span class="kn">import</span> <span class="n">MissingFilesDialog</span>
<span class="kn">from</span> <span class="nn">sleap.rangelist</span> <span class="kn">import</span> <span class="n">RangeList</span>
<span class="kn">from</span> <span class="nn">sleap.util</span> <span class="kn">import</span> <span class="n">uniquify</span><span class="p">,</span> <span class="n">weak_filename_match</span><span class="p">,</span> <span class="n">json_dumps</span><span class="p">,</span> <span class="n">json_loads</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The version number to put in the Labels JSON format.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">LABELS_JSON_FILE_VERSION</span> <span class="o">=</span> <span class="s2">&quot;2.0.0&quot;</span>


<div class="viewcode-block" id="Labels"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Labels</span><span class="p">(</span><span class="n">MutableSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`Labels` class collects the data for a SLEAP project.</span>

<span class="sd">    This class is front-end for all interactions with loading, writing,</span>
<span class="sd">    and modifying these labels. The actual storage backend for the data</span>
<span class="sd">    is mostly abstracted away from the main interface.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        labeled_frames: A list of :class:`LabeledFrame` objects</span>
<span class="sd">        videos: A list of :class:`Video` objects that these labels may or may</span>
<span class="sd">            not reference. The video for every `LabeledFrame` will be</span>
<span class="sd">            stored in `videos` attribute, but some videos in</span>
<span class="sd">            this list may not have any associated labeled frames.</span>
<span class="sd">        skeletons: A list of :class:`Skeleton` objects (again, that may or may</span>
<span class="sd">            not be referenced by an :class:`Instance` in labeled frame).</span>
<span class="sd">        tracks: A list of :class:`Track` that instances can belong to.</span>
<span class="sd">        suggestions: List that stores &quot;suggested&quot; frames for</span>
<span class="sd">            videos in project. These can be suggested frames for user</span>
<span class="sd">            to label or suggested frames for user to review.</span>
<span class="sd">        negative_anchors: Dictionary that stores center-points around</span>
<span class="sd">            which to crop as negative samples when training.</span>
<span class="sd">            Dictionary key is :class:`Video`, value is list of</span>
<span class="sd">            (frame index, x, y) tuples.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">labeled_frames</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">LabeledFrame</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">Factory</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
    <span class="n">videos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Video</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">Factory</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
    <span class="n">skeletons</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Skeleton</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">Factory</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">Factory</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
    <span class="n">tracks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Track</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">Factory</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
    <span class="n">suggestions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;SuggestionFrame&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">Factory</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
    <span class="n">negative_anchors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Video</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">Factory</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by attrs after the class is instantiated.</span>

<span class="sd">        This updates the top level contains (videos, skeletons, etc)</span>
<span class="sd">        from data in the labeled frames, as well as various caches.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Add any videos/skeletons/nodes/tracks that are in labeled</span>
        <span class="c1"># frames but not in the lists on our object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_from_labels</span><span class="p">()</span>

        <span class="c1"># Update caches used to find frames by frame index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_lookup_caches</span><span class="p">()</span>

        <span class="c1"># Create a variable to store a temporary storage directory</span>
        <span class="c1"># used when we unzip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__temp_dir</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_from_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">merge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates top level attributes with data from labeled frames.</span>

<span class="sd">        Args:</span>
<span class="sd">            merge: If True, then update even if there&#39;s already data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Add any videos that are present in the labels but</span>
        <span class="c1"># missing from the video list</span>
        <span class="k">if</span> <span class="n">merge</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># find videos in labeled frames that aren&#39;t yet in top level videos</span>
            <span class="n">new_videos</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="o">.</span><span class="n">video</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">}</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">)</span>
            <span class="c1"># just add the new videos so we don&#39;t re-order current list</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_videos</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_videos</span><span class="p">))</span>

        <span class="c1"># Ditto for skeletons</span>
        <span class="k">if</span> <span class="n">merge</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">instance</span><span class="o">.</span><span class="n">skeleton</span>
                        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
                        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">label</span><span class="o">.</span><span class="n">instances</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Ditto for nodes</span>
        <span class="k">if</span> <span class="n">merge</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">node</span> <span class="k">for</span> <span class="n">skeleton</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">}</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Ditto for tracks, a pattern is emerging here</span>
        <span class="k">if</span> <span class="n">merge</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Get tracks from any Instances or PredictedInstances</span>
            <span class="n">other_tracks</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">instance</span><span class="o">.</span><span class="n">track</span>
                <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
                <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">instances</span>
                <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">track</span>
            <span class="p">}</span>

            <span class="c1"># Add tracks from any PredictedInstance referenced by instance</span>
            <span class="c1"># This fixes things when there&#39;s a referenced PredictionInstance</span>
            <span class="c1"># which is no longer in the frame.</span>
            <span class="n">other_tracks</span> <span class="o">=</span> <span class="n">other_tracks</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="n">instance</span><span class="o">.</span><span class="n">from_predicted</span><span class="o">.</span><span class="n">track</span>
                    <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
                    <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">instances</span>
                    <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">from_predicted</span> <span class="ow">and</span> <span class="n">instance</span><span class="o">.</span><span class="n">from_predicted</span><span class="o">.</span><span class="n">track</span>
                <span class="p">}</span>
            <span class="p">)</span>

            <span class="c1"># Get list of other tracks not already in track list</span>
            <span class="n">new_tracks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other_tracks</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">))</span>

            <span class="c1"># Sort the new tracks by spawned on and then name</span>
            <span class="n">new_tracks</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">spawned_on</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_tracks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_containers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_label</span><span class="p">:</span> <span class="n">LabeledFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Ensure that top-level containers are kept updated with new</span>
<span class="sd">        instances of objects that come along with new labels. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">new_label</span><span class="o">.</span><span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_label</span><span class="o">.</span><span class="n">video</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">skeleton</span> <span class="ow">in</span> <span class="p">{</span><span class="n">instance</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">new_label</span><span class="p">}:</span>
            <span class="k">if</span> <span class="n">skeleton</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Add any new Tracks as well</span>
        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">new_label</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="ow">and</span> <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">)</span>

        <span class="c1"># Sort the tracks again</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">spawned_on</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="c1"># Update cache datastructures</span>
        <span class="k">if</span> <span class="n">new_label</span><span class="o">.</span><span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">[</span><span class="n">new_label</span><span class="o">.</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">new_label</span><span class="o">.</span><span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">new_label</span><span class="o">.</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">[</span><span class="n">new_label</span><span class="o">.</span><span class="n">video</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">new_label</span><span class="o">.</span><span class="n">video</span><span class="p">][</span><span class="n">new_label</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_label</span>

    <span class="k">def</span> <span class="nf">_build_lookup_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds (or rebuilds) various caches.&quot;&quot;&quot;</span>
        <span class="c1"># Data structures for caching</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">video</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">[</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">lf</span> <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="k">if</span> <span class="n">lf</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">:</span> <span class="n">lf</span> <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">[</span><span class="n">video</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_track_occupany</span><span class="p">(</span><span class="n">video</span><span class="p">)</span>

    <span class="c1"># Below are convenience methods for working with Labels as list.</span>
    <span class="c1"># Maybe we should just inherit from list? Maybe this class shouldn&#39;t</span>
    <span class="c1"># exists since it is just a list really with some class methods. I</span>
    <span class="c1"># think more stuff might appear in this class later down the line</span>
    <span class="c1"># though.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alias for labeled_frames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of labeled frames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="p">)</span>

<div class="viewcode-block" id="Labels.index"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns index of labeled frame in list of labeled frames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if object contains the given item.</span>

<span class="sd">        Args:</span>
<span class="sd">            item: The item to look for within `Labels`.</span>
<span class="sd">                This can be :class:`LabeledFrame`,</span>
<span class="sd">                :class:`Video`, :class:`Skeleton`,</span>
<span class="sd">                :class:`Node`, or (:class:`Video`, frame idx) tuple.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if item is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">LabeledFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Video</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Skeleton</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Video</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_first</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">LabeledFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns labeled frames matching key.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: `Video` or (`Video`, frame index) to match against.</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: If labeled frame for `Video` or frame index</span>
<span class="sd">            cannot be found.</span>

<span class="sd">        Returns: A list with the matching labeled frame(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Video</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Video not found in labels.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">video</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Video</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Video not found in labels.&quot;</span><span class="p">)</span>

            <span class="n">_hit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_first</span><span class="p">(</span><span class="n">video</span><span class="o">=</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">frame_idx</span><span class="o">=</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">_hit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No label found for specified video at frame </span><span class="si">{key[1]}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">_hit</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Invalid label indexing arguments.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">LabeledFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets labeled frame at given index.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Maybe we should remove this method altogether?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_containers</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="Labels.insert"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">LabeledFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inserts labeled frame at given index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">or</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">video</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_containers</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Labels.append"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">LabeledFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds labeled frame to list of labeled frames.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes labeled frame with given index.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

<div class="viewcode-block" id="Labels.remove"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">LabeledFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes given labeled frame.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">video</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">video</span><span class="p">][</span><span class="n">value</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="Labels.find"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span>
        <span class="n">frame_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">range</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_new</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">LabeledFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; Search for labeled frames given video and/or frame index.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: A :class:`Video` that is associated with the project.</span>
<span class="sd">            frame_idx: The frame index (or indices) which we want to</span>
<span class="sd">                find in the video. If a range is specified, we&#39;ll return</span>
<span class="sd">                all frames with indices in that range. If not specific,</span>
<span class="sd">                then we&#39;ll return all labeled frames for video.</span>
<span class="sd">            return_new: Whether to return singleton of new and empty</span>
<span class="sd">                :class:`LabeledFrame` if none is found in project.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of `LabeledFrame` objects that match the criteria.</span>
<span class="sd">            Empty if no matches found, unless return_new is True,</span>
<span class="sd">            in which case it contains a new `LabeledFrame` with</span>
<span class="sd">            `video` and `frame_index` set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">null_result</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">LabeledFrame</span><span class="p">(</span><span class="n">video</span><span class="o">=</span><span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="o">=</span><span class="n">frame_idx</span><span class="p">)]</span> <span class="k">if</span> <span class="n">return_new</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">frame_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">null_result</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">frame_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">range</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">frame_idx</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">video</span><span class="p">]</span>
                <span class="p">]</span>

            <span class="k">if</span> <span class="n">frame_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">video</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">null_result</span>

            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">frame_idx</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">null_result</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">[</span><span class="n">video</span><span class="p">]</span></div>

<div class="viewcode-block" id="Labels.frames"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.frames">[docs]</a>    <span class="k">def</span> <span class="nf">frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span> <span class="n">from_frame_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all labeled frames in a video.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: A :class:`Video` that is associated with the project.</span>
<span class="sd">            from_frame_idx: The frame index from which we want to start.</span>
<span class="sd">                Defaults to the first frame of video.</span>
<span class="sd">            reverse: Whether to iterate over frames in reverse order.</span>

<span class="sd">        Yields:</span>
<span class="sd">            :class:`LabeledFrame`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Get sorted list of frame indexes for this video</span>
        <span class="n">frame_idxs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">video</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Find the next frame index after (before) the specified frame</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">next_frame_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">from_frame_idx</span><span class="p">,</span> <span class="n">frame_idxs</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="n">frame_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">next_frame_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">from_frame_idx</span><span class="p">,</span> <span class="n">frame_idxs</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="n">frame_idxs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">cut_list_idx</span> <span class="o">=</span> <span class="n">frame_idxs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">next_frame_idx</span><span class="p">)</span>

        <span class="c1"># Shift list of frame indices to start with specified frame</span>
        <span class="n">frame_idxs</span> <span class="o">=</span> <span class="n">frame_idxs</span><span class="p">[</span><span class="n">cut_list_idx</span><span class="p">:]</span> <span class="o">+</span> <span class="n">frame_idxs</span><span class="p">[:</span><span class="n">cut_list_idx</span><span class="p">]</span>

        <span class="c1"># Yield the frames</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">frame_idxs</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="Labels.find_first"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.find_first">[docs]</a>    <span class="k">def</span> <span class="nf">find_first</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LabeledFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the first occurrence of a matching labeled frame.</span>

<span class="sd">        Matches on frames for the given video and/or frame index.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: a `Video` instance that is associated with the</span>
<span class="sd">                labeled frames</span>
<span class="sd">            frame_idx: an integer specifying the frame index within</span>
<span class="sd">                the video</span>

<span class="sd">        Returns:</span>
<span class="sd">            First `LabeledFrame` that match the criteria</span>
<span class="sd">            or None if none were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">video</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">label</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">frame_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">==</span> <span class="n">frame_idx</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="n">label</span></div>

<div class="viewcode-block" id="Labels.find_last"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.find_last">[docs]</a>    <span class="k">def</span> <span class="nf">find_last</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LabeledFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the last occurrence of a matching labeled frame.</span>

<span class="sd">        Matches on frames for the given video and/or frame index.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: a `Video` instance that is associated with the</span>
<span class="sd">                labeled frames</span>
<span class="sd">            frame_idx: an integer specifying the frame index within</span>
<span class="sd">                the video</span>

<span class="sd">        Returns:</span>
<span class="sd">            Last `LabeledFrame` that match the criteria</span>
<span class="sd">            or None if none were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">video</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">label</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">frame_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">==</span> <span class="n">frame_idx</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="n">label</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_labeled_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all labeled frames with user (non-predicted) instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">lf</span> <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span> <span class="k">if</span> <span class="n">lf</span><span class="o">.</span><span class="n">has_user_instances</span><span class="p">]</span>

<div class="viewcode-block" id="Labels.get_video_user_labeled_frames"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.get_video_user_labeled_frames">[docs]</a>    <span class="k">def</span> <span class="nf">get_video_user_labeled_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">LabeledFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns labeled frames for given video with user instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">lf</span>
            <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span>
            <span class="k">if</span> <span class="n">lf</span><span class="o">.</span><span class="n">has_user_instances</span> <span class="ow">and</span> <span class="n">lf</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span>
        <span class="p">]</span></div>

    <span class="c1"># Methods for instances</span>

<div class="viewcode-block" id="Labels.instance_count"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.instance_count">[docs]</a>    <span class="k">def</span> <span class="nf">instance_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of instances matching video/frame index.&quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">labeled_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_first</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labeled_frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                <span class="p">[</span><span class="n">inst</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">labeled_frame</span><span class="o">.</span><span class="n">instances</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span> <span class="o">==</span> <span class="n">Instance</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns list of all instances.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns list of all user (non-predicted) instances.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">inst</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_instances</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span> <span class="o">==</span> <span class="n">Instance</span><span class="p">]</span>

<div class="viewcode-block" id="Labels.instances"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.instances">[docs]</a>    <span class="k">def</span> <span class="nf">instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">:</span> <span class="n">Skeleton</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over instances in the labels, optionally with filters.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: Only iterate through instances in this video</span>
<span class="sd">            skeleton: Only iterate through instances with this skeleton</span>

<span class="sd">        Yields:</span>
<span class="sd">            Instance: The next labeled instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">video</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">label</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">label</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">instance</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">==</span> <span class="n">skeleton</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">instance</span></div>

    <span class="c1"># Methods for tracks</span>

<div class="viewcode-block" id="Labels.get_track_occupany"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.get_track_occupany">[docs]</a>    <span class="k">def</span> <span class="nf">get_track_occupany</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns track occupancy list for given video&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Labels.add_track"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.add_track">[docs]</a>    <span class="k">def</span> <span class="nf">add_track</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span> <span class="n">track</span><span class="p">:</span> <span class="n">Track</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds track to labels, updating occupancy.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="n">RangeList</span><span class="p">()</span></div>

<div class="viewcode-block" id="Labels.track_set_instance"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.track_set_instance">[docs]</a>    <span class="k">def</span> <span class="nf">track_set_instance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span> <span class="n">LabeledFrame</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="n">Instance</span><span class="p">,</span> <span class="n">new_track</span><span class="p">:</span> <span class="n">Track</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets track on given instance, updating occupancy.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">track_swap</span><span class="p">(</span>
            <span class="n">frame</span><span class="o">.</span><span class="n">video</span><span class="p">,</span>
            <span class="n">new_track</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">,</span>
            <span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_remove_instance</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="o">=</span> <span class="n">new_track</span></div>

<div class="viewcode-block" id="Labels.track_swap"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.track_swap">[docs]</a>    <span class="k">def</span> <span class="nf">track_swap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span>
        <span class="n">new_track</span><span class="p">:</span> <span class="n">Track</span><span class="p">,</span>
        <span class="n">old_track</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Track</span><span class="p">],</span>
        <span class="n">frame_range</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swaps track assignment for instances in two tracks.</span>

<span class="sd">        If you need to change the track to or from None, you&#39;ll need</span>
<span class="sd">        to use :meth:`track_set_instance` for each specific</span>
<span class="sd">        instance you want to modify.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: The :class:`Video` for which we want to swap tracks.</span>
<span class="sd">            new_track: A :class:`Track` for which we want to swap</span>
<span class="sd">                instances with another track.</span>
<span class="sd">            old_track: The other :class:`Track` for swapping.</span>
<span class="sd">            frame_range: Tuple of (start, end) frame indexes.</span>
<span class="sd">                If you want to swap tracks on a single frame, use</span>
<span class="sd">                (frame index, frame index + 1).</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get ranges in track occupancy cache</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">within_old</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_track_occupany</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">old_track</span><span class="p">)</span><span class="o">.</span><span class="n">cut_range</span><span class="p">(</span>
            <span class="n">frame_range</span>
        <span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">within_new</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_track_occupany</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">new_track</span><span class="p">)</span><span class="o">.</span><span class="n">cut_range</span><span class="p">(</span>
            <span class="n">frame_range</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">old_track</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Instances that didn&#39;t already have track can&#39;t be handled here.</span>
            <span class="c1"># See track_set_instance for this case.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">old_track</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">frame_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">new_track</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">frame_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">old_track</span><span class="p">]</span><span class="o">.</span><span class="n">insert_list</span><span class="p">(</span><span class="n">within_new</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">new_track</span><span class="p">]</span><span class="o">.</span><span class="n">insert_list</span><span class="p">(</span><span class="n">within_old</span><span class="p">)</span>

        <span class="c1"># Update tracks set on instances</span>

        <span class="c1"># Get all instances in old/new tracks</span>
        <span class="c1"># Note that this won&#39;t match on None track.</span>
        <span class="n">old_track_instances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_track_occupancy</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">old_track</span><span class="p">,</span> <span class="n">frame_range</span><span class="p">)</span>
        <span class="n">new_track_instances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_track_occupancy</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">new_track</span><span class="p">,</span> <span class="n">frame_range</span><span class="p">)</span>

        <span class="c1"># swap new to old tracks on all instances</span>
        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">old_track_instances</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="o">=</span> <span class="n">new_track</span>
        <span class="c1"># old_track can be `Track` or int</span>
        <span class="c1"># If int, it&#39;s index in instance list which we&#39;ll use as a pseudo-track,</span>
        <span class="c1"># but we won&#39;t set instances currently on new_track to old_track.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">old_track</span><span class="p">)</span> <span class="o">==</span> <span class="n">Track</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">new_track_instances</span><span class="p">:</span>
                <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="o">=</span> <span class="n">old_track</span></div>

    <span class="k">def</span> <span class="nf">_track_remove_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span> <span class="n">LabeledFrame</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="n">Instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Manipulates track occupancy cache.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">video</span><span class="p">]:</span>
            <span class="k">return</span>

        <span class="c1"># If this is only instance in track in frame, then remove frame from track.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">track</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">video</span><span class="p">][</span><span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

<div class="viewcode-block" id="Labels.remove_instance"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.remove_instance">[docs]</a>    <span class="k">def</span> <span class="nf">remove_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span> <span class="n">LabeledFrame</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="n">Instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes instance from frame, updating track occupancy.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_remove_instance</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
        <span class="n">frame</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span></div>

<div class="viewcode-block" id="Labels.add_instance"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.add_instance">[docs]</a>    <span class="k">def</span> <span class="nf">add_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span> <span class="n">LabeledFrame</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="n">Instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds instance to frame, updating track occupancy.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Ensure that there isn&#39;t already an Instance with this track</span>
        <span class="n">tracks_in_frame</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">track</span>
            <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">frame</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span> <span class="o">==</span> <span class="n">Instance</span> <span class="ow">and</span> <span class="n">inst</span><span class="o">.</span><span class="n">track</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="ow">in</span> <span class="n">tracks_in_frame</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Add track in its not already present in labels</span>
        <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">video</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">video</span><span class="p">][</span><span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="n">RangeList</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">video</span><span class="p">][</span><span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
            <span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">frame</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_make_track_occupany</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Video</span><span class="p">,</span> <span class="n">RangeList</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Build cached track occupancy data.&quot;&quot;&quot;</span>
        <span class="n">frame_idx_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">video</span><span class="p">]</span>

        <span class="n">tracks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">frame_idxs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">frame_idx_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">frame_idx</span> <span class="ow">in</span> <span class="n">frame_idxs</span><span class="p">:</span>
            <span class="n">instances</span> <span class="o">=</span> <span class="n">frame_idx_map</span><span class="p">[</span><span class="n">frame_idx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tracks</span><span class="p">:</span>
                    <span class="n">tracks</span><span class="p">[</span><span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="n">RangeList</span><span class="p">()</span>
                <span class="n">tracks</span><span class="p">[</span><span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">frame_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tracks</span>

    <span class="k">def</span> <span class="nf">_get_track_occupany</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span> <span class="n">track</span><span class="p">:</span> <span class="n">Track</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RangeList</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Accessor for track occupancy cache that adds video/track as needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">track</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="n">RangeList</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_track_occupancy</span><span class="p">[</span><span class="n">video</span><span class="p">][</span><span class="n">track</span><span class="p">]</span>

<div class="viewcode-block" id="Labels.find_track_occupancy"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.find_track_occupancy">[docs]</a>    <span class="k">def</span> <span class="nf">find_track_occupancy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span> <span class="n">track</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Track</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">frame_range</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get instances for a given video, track, and range of frames.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: the `Video`</span>
<span class="sd">            track: the `Track` or int (&quot;pseudo-track&quot; index to instance list)</span>
<span class="sd">            frame_range (optional):</span>
<span class="sd">                If specified, only return instances on frames in range.</span>
<span class="sd">                If None, return all instances for given track.</span>
<span class="sd">        Returns:</span>
<span class="sd">            List of :class:`Instance` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">frame_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">frame_range</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">frame_range</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span> <span class="k">else</span> <span class="n">frame_range</span>

        <span class="k">def</span> <span class="nf">does_track_match</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">labeled_frame</span><span class="p">):</span>
            <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">==</span> <span class="n">Track</span> <span class="ow">and</span> <span class="n">inst</span><span class="o">.</span><span class="n">track</span> <span class="ow">is</span> <span class="n">tr</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
                <span class="ow">and</span> <span class="n">labeled_frame</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span> <span class="o">==</span> <span class="n">tr</span>
                <span class="ow">and</span> <span class="n">inst</span><span class="o">.</span><span class="n">track</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">match</span>

        <span class="n">track_frame_inst</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">instance</span>
            <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">video</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">lf</span><span class="o">.</span><span class="n">instances</span>
            <span class="k">if</span> <span class="n">does_track_match</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">lf</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">frame_range</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span> <span class="ow">in</span> <span class="n">frame_range</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">track_frame_inst</span></div>

    <span class="c1"># Methods for suggestions</span>

<div class="viewcode-block" id="Labels.get_video_suggestions"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.get_video_suggestions">[docs]</a>    <span class="k">def</span> <span class="nf">get_video_suggestions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of suggested frames for the specified video</span>
<span class="sd">        or suggestions for all videos (if no video specified).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">frame_idx</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suggestions</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span><span class="p">]</span></div>

<div class="viewcode-block" id="Labels.get_suggestions"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.get_suggestions">[docs]</a>    <span class="k">def</span> <span class="nf">get_suggestions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all suggestions as a list of SuggestionFrame items.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">suggestions</span></div>

<div class="viewcode-block" id="Labels.find_suggestion"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.find_suggestion">[docs]</a>    <span class="k">def</span> <span class="nf">find_suggestion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find SuggestionFrame by video and frame index.&quot;&quot;&quot;</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">item</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suggestions</span>
            <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">==</span> <span class="n">frame_idx</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Labels.get_next_suggestion"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.get_next_suggestion">[docs]</a>    <span class="k">def</span> <span class="nf">get_next_suggestion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">,</span> <span class="n">seek_direction</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a (video, frame_idx) tuple seeking from given frame.&quot;&quot;&quot;</span>
        <span class="c1"># make sure we have valid seek_direction</span>
        <span class="k">if</span> <span class="n">seek_direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;seek_direction should be -1 or 1.&quot;</span><span class="p">)</span>
        <span class="c1"># make sure the video belongs to this Labels object</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">all_suggestions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_suggestions</span><span class="p">()</span>

        <span class="c1"># If we&#39;re currently on a suggestion, then follow order of list</span>
        <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_suggestion</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">suggestion_idx</span> <span class="o">=</span> <span class="n">all_suggestions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
            <span class="n">new_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">suggestion_idx</span> <span class="o">+</span> <span class="n">seek_direction</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_suggestions</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">all_suggestions</span><span class="p">[</span><span class="n">new_idx</span><span class="p">]</span>

        <span class="c1"># Otherwise, find the prev/next suggestion sorted by frame order...</span>

        <span class="c1"># Look for next (or previous) suggestion in current video.</span>
        <span class="k">if</span> <span class="n">seek_direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">frame_suggestion</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_video_suggestions</span><span class="p">(</span><span class="n">video</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">frame_idx</span><span class="p">),</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frame_suggestion</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_video_suggestions</span><span class="p">(</span><span class="n">video</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">frame_idx</span><span class="p">),</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">frame_suggestion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_suggestion</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">frame_suggestion</span><span class="p">)</span>

        <span class="c1"># If we didn&#39;t find suggestion in current video, then we want earliest</span>
        <span class="c1"># frame in next video with suggestions.</span>
        <span class="n">next_video_idx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">video</span><span class="p">)</span> <span class="o">+</span> <span class="n">seek_direction</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">)</span>
        <span class="n">video</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">[</span><span class="n">next_video_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">seek_direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">frame_suggestion</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_video_suggestions</span><span class="p">(</span><span class="n">video</span><span class="p">)),</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frame_suggestion</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_video_suggestions</span><span class="p">(</span><span class="n">video</span><span class="p">)),</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_suggestion</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">frame_suggestion</span><span class="p">)</span></div>

<div class="viewcode-block" id="Labels.set_suggestions"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.set_suggestions">[docs]</a>    <span class="k">def</span> <span class="nf">set_suggestions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suggestions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;SuggestionFrame&quot;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Sets the suggested frames.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suggestions</span> <span class="o">=</span> <span class="n">suggestions</span></div>

<div class="viewcode-block" id="Labels.delete_suggestions"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.delete_suggestions">[docs]</a>    <span class="k">def</span> <span class="nf">delete_suggestions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes suggestions for specified video.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suggestions</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suggestions</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">video</span> <span class="o">!=</span> <span class="n">video</span><span class="p">]</span></div>

    <span class="c1"># Methods for videos</span>

<div class="viewcode-block" id="Labels.add_video"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.add_video">[docs]</a>    <span class="k">def</span> <span class="nf">add_video</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a video to the labels if it is not already in it.</span>

<span class="sd">        Video instances are added automatically when adding labeled frames,</span>
<span class="sd">        but this function allows for adding videos to the labels before any</span>
<span class="sd">        labeled frames are added.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: `Video` instance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">video</span><span class="p">)</span></div>

<div class="viewcode-block" id="Labels.remove_video"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.remove_video">[docs]</a>    <span class="k">def</span> <span class="nf">remove_video</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Removes a video from the labels and ALL associated labeled frames.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: `Video` instance to be removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Video is not in labels.&quot;</span><span class="p">)</span>

        <span class="c1"># Delete all associated labeled frames</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># Delete data that&#39;s indexed by video</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_suggestions</span><span class="p">(</span><span class="n">video</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">[</span><span class="n">video</span><span class="p">]</span>

        <span class="c1"># Delete video</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">video</span><span class="p">)</span>

        <span class="c1"># Remove from caches</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lf_by_video</span><span class="p">[</span><span class="n">video</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_idx_map</span><span class="p">[</span><span class="n">video</span><span class="p">]</span></div>

    <span class="c1"># Methods for negative anchors</span>

<div class="viewcode-block" id="Labels.add_negative_anchor"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.add_negative_anchor">[docs]</a>    <span class="k">def</span> <span class="nf">add_negative_anchor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">where</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a location for a negative training sample.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: the `Video` for this negative sample</span>
<span class="sd">            frame_idx: frame index</span>
<span class="sd">            where: (x, y)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">[</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">[</span><span class="n">video</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frame_idx</span><span class="p">,</span> <span class="o">*</span><span class="n">where</span><span class="p">))</span></div>

<div class="viewcode-block" id="Labels.remove_negative_anchors"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.remove_negative_anchors">[docs]</a>    <span class="k">def</span> <span class="nf">remove_negative_anchors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes negative training samples for given video and frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: the `Video` for which we&#39;re removing negative samples</span>
<span class="sd">            frame_idx: frame index</span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">anchors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">[</span><span class="n">video</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">frame_idx</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">[</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="n">anchors</span></div>

    <span class="c1"># Methods for saving/loading</span>

<div class="viewcode-block" id="Labels.extend_from"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.extend_from">[docs]</a>    <span class="k">def</span> <span class="nf">extend_from</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">new_frames</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Labels&quot;</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">LabeledFrame</span><span class="p">]],</span> <span class="n">unify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge data from another `Labels` object or `LabeledFrame` list.</span>

<span class="sd">        Arg:</span>
<span class="sd">            new_frames: the object from which to copy data</span>
<span class="sd">            unify: whether to replace objects in new frames with</span>
<span class="sd">                corresponding objects from current `Labels` data</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool, True if we added frames, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># allow either Labels or list of LabeledFrames</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_frames</span><span class="p">,</span> <span class="n">Labels</span><span class="p">):</span>
            <span class="n">new_frames</span> <span class="o">=</span> <span class="n">new_frames</span><span class="o">.</span><span class="n">labeled_frames</span>

        <span class="c1"># return if this isn&#39;t non-empty list of labeled frames</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_frames</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_frames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LabeledFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If unify, we want to replace objects in the frames with</span>
        <span class="c1"># corresponding objects from the current labels.</span>
        <span class="c1"># We do this by deserializing/serializing with match_to.</span>
        <span class="k">if</span> <span class="n">unify</span><span class="p">:</span>
            <span class="n">new_json</span> <span class="o">=</span> <span class="n">Labels</span><span class="p">(</span><span class="n">labeled_frames</span><span class="o">=</span><span class="n">new_frames</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="n">new_labels</span> <span class="o">=</span> <span class="n">Labels</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">new_json</span><span class="p">,</span> <span class="n">match_to</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new_frames</span> <span class="o">=</span> <span class="n">new_labels</span><span class="o">.</span><span class="n">labeled_frames</span>

        <span class="c1"># copy the labeled frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_frames</span><span class="p">)</span>

        <span class="c1"># merge labeled frames for the same video/frame idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_matching_frames</span><span class="p">()</span>

        <span class="c1"># update top level videos/nodes/skeletons/tracks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_from_labels</span><span class="p">(</span><span class="n">merge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_lookup_caches</span><span class="p">()</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Labels.complex_merge_between"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.complex_merge_between">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">complex_merge_between</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">base_labels</span><span class="p">:</span> <span class="s2">&quot;Labels&quot;</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">:</span> <span class="s2">&quot;Labels&quot;</span><span class="p">,</span> <span class="n">unify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge frames and other data from one dataset into another.</span>

<span class="sd">        Anything that can be merged cleanly is merged into base_labels.</span>

<span class="sd">        Frames conflict just in case each labels object has a matching</span>
<span class="sd">        frame (same video and frame idx) with instances not in other.</span>

<span class="sd">        Frames can be merged cleanly if:</span>

<span class="sd">        * the frame is in only one of the labels, or</span>
<span class="sd">        * the frame is in both labels, but all instances perfectly match</span>
<span class="sd">          (which means they are redundant), or</span>
<span class="sd">        * the frame is in both labels, maybe there are some redundant</span>
<span class="sd">          instances, but only one version of the frame has additional</span>
<span class="sd">          instances not in the other.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_labels: the `Labels` that we&#39;re merging into</span>
<span class="sd">            new_labels: the `Labels` that we&#39;re merging from</span>
<span class="sd">            unify: whether to replace objects (e.g., `Video`) in</span>
<span class="sd">                new_labels with *matching* objects from base</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of three items:</span>

<span class="sd">            * Dictionary, keys are :class:`Video`, values are</span>
<span class="sd">                dictionary in which keys are frame index (int)</span>
<span class="sd">                and value is list of :class:`Instance` objects</span>
<span class="sd">            * list of conflicting :class:`Instance` objects from base</span>
<span class="sd">            * list of conflicting :class:`Instance` objects from new</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If unify, we want to replace objects in the frames with</span>
        <span class="c1"># corresponding objects from the current labels.</span>
        <span class="c1"># We do this by deserializing/serializing with match_to.</span>
        <span class="k">if</span> <span class="n">unify</span><span class="p">:</span>
            <span class="n">new_json</span> <span class="o">=</span> <span class="n">new_labels</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="n">new_labels</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">new_json</span><span class="p">,</span> <span class="n">match_to</span><span class="o">=</span><span class="n">base_labels</span><span class="p">)</span>

        <span class="c1"># Merge anything that can be merged cleanly and get conflicts</span>
        <span class="n">merged</span><span class="p">,</span> <span class="n">extra_base</span><span class="p">,</span> <span class="n">extra_new</span> <span class="o">=</span> <span class="n">LabeledFrame</span><span class="o">.</span><span class="n">complex_merge_between</span><span class="p">(</span>
            <span class="n">base_labels</span><span class="o">=</span><span class="n">base_labels</span><span class="p">,</span> <span class="n">new_frames</span><span class="o">=</span><span class="n">new_labels</span><span class="o">.</span><span class="n">labeled_frames</span>
        <span class="p">)</span>

        <span class="c1"># For clean merge, finish merge now by cleaning up base object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">extra_base</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">extra_new</span><span class="p">:</span>
            <span class="c1"># Add any new videos (etc) into top level lists in base</span>
            <span class="n">base_labels</span><span class="o">.</span><span class="n">_update_from_labels</span><span class="p">(</span><span class="n">merge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Update caches</span>
            <span class="n">base_labels</span><span class="o">.</span><span class="n">_build_lookup_caches</span><span class="p">()</span>

        <span class="c1"># Merge suggestions and negative anchors</span>
        <span class="n">base_labels</span><span class="o">.</span><span class="n">suggestions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_labels</span><span class="o">.</span><span class="n">suggestions</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">merge_container_dicts</span><span class="p">(</span>
            <span class="n">base_labels</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">,</span> <span class="n">new_labels</span><span class="o">.</span><span class="n">negative_anchors</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">merged</span><span class="p">,</span> <span class="n">extra_base</span><span class="p">,</span> <span class="n">extra_new</span></div>

    <span class="c1">#     @classmethod</span>
    <span class="c1">#     def merge_predictions_by_score(cls, extra_base: List[LabeledFrame], extra_new: List[LabeledFrame]):</span>
    <span class="c1">#         &quot;&quot;&quot;</span>
    <span class="c1">#         Remove all predictions from input lists, return list with only</span>
    <span class="c1">#         the merged predictions.</span>
    <span class="c1">#</span>
    <span class="c1">#         Args:</span>
    <span class="c1">#             extra_base: list of `LabeledFrame` objects</span>
    <span class="c1">#             extra_new: list of `LabeledFrame` objects</span>
    <span class="c1">#                 Conflicting frames should have same index in both lists.</span>
    <span class="c1">#         Returns:</span>
    <span class="c1">#             list of `LabeledFrame` objects with merged predictions</span>
    <span class="c1">#         &quot;&quot;&quot;</span>
    <span class="c1">#         pass</span>

<div class="viewcode-block" id="Labels.finish_complex_merge"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.finish_complex_merge">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">finish_complex_merge</span><span class="p">(</span>
        <span class="n">base_labels</span><span class="p">:</span> <span class="s2">&quot;Labels&quot;</span><span class="p">,</span> <span class="n">resolved_frames</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">LabeledFrame</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finish conflicted merge from complex_merge_between.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_labels: the `Labels` that we&#39;re merging into</span>
<span class="sd">            resolved_frames: the list of frames to add into base_labels</span>
<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add all the resolved frames to base</span>
        <span class="n">base_labels</span><span class="o">.</span><span class="n">labeled_frames</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">resolved_frames</span><span class="p">)</span>

        <span class="c1"># Combine instances when there are two LabeledFrames for same</span>
        <span class="c1"># video and frame index</span>
        <span class="n">base_labels</span><span class="o">.</span><span class="n">merge_matching_frames</span><span class="p">()</span>

        <span class="c1"># Add any new videos (etc) into top level lists in base</span>
        <span class="n">base_labels</span><span class="o">.</span><span class="n">_update_from_labels</span><span class="p">(</span><span class="n">merge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Update caches</span>
        <span class="n">base_labels</span><span class="o">.</span><span class="n">_build_lookup_caches</span><span class="p">()</span></div>

<div class="viewcode-block" id="Labels.merge_container_dicts"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.merge_container_dicts">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_container_dicts</span><span class="p">(</span><span class="n">dict_a</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">dict_b</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Merge data from dict_b into dict_a.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_b</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_a</span><span class="p">:</span>
                <span class="n">dict_a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dict_b</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="n">uniquify</span><span class="p">(</span><span class="n">dict_a</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dict_a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_b</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="Labels.merge_matching_frames"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.merge_matching_frames">[docs]</a>    <span class="k">def</span> <span class="nf">merge_matching_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">video</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Video</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge `LabeledFrame` objects that are for the same video frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            video: combine for this video; if None, do all videos</span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">video</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="p">{</span><span class="n">lf</span><span class="o">.</span><span class="n">video</span> <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="p">}:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merge_matching_frames</span><span class="p">(</span><span class="n">video</span><span class="o">=</span><span class="n">vid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span> <span class="o">=</span> <span class="n">LabeledFrame</span><span class="o">.</span><span class="n">merge_frames</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="p">,</span> <span class="n">video</span><span class="o">=</span><span class="n">video</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Labels.to_dict"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize all labels in the underling list of LabeledFrames to a</span>
<span class="sd">        dict structure. This function returns a nested dict structure</span>
<span class="sd">        composed entirely of primitive python types. It is used to create</span>
<span class="sd">        JSON and HDF5 serialized datasets.</span>

<span class="sd">        Args:</span>
<span class="sd">            skip_labels: If True, skip labels serialization and just do the</span>
<span class="sd">            metadata.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dict containing the followings top level keys:</span>
<span class="sd">            * version - The version of the dict/json serialization format.</span>
<span class="sd">            * skeletons - The skeletons associated with these underlying</span>
<span class="sd">              instances.</span>
<span class="sd">            * nodes - The nodes that the skeletons represent.</span>
<span class="sd">            * videos - The videos that that the instances occur on.</span>
<span class="sd">            * labels - The labeled frames</span>
<span class="sd">            * tracks - The tracks associated with each instance.</span>
<span class="sd">            * suggestions - The suggested frames.</span>
<span class="sd">            * negative_anchors - The negative training sample anchors.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># FIXME: Update list of nodes</span>
        <span class="c1"># We shouldn&#39;t have to do this here, but for some reason we&#39;re missing nodes</span>
        <span class="c1"># which are in the skeleton but don&#39;t have points (in the first instance?).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="p">{</span><span class="n">node</span> <span class="k">for</span> <span class="n">skeleton</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Register some unstructure hooks since we don&#39;t want complete deserialization</span>
        <span class="c1"># of video and skeleton objects present in the labels. We will serialize these</span>
        <span class="c1"># as references to the above constructed lists to limit redundant data in the</span>
        <span class="c1"># json</span>
        <span class="n">label_cattr</span> <span class="o">=</span> <span class="n">make_instance_cattr</span><span class="p">()</span>
        <span class="n">label_cattr</span><span class="o">.</span><span class="n">register_unstructure_hook</span><span class="p">(</span>
            <span class="n">Skeleton</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">label_cattr</span><span class="o">.</span><span class="n">register_unstructure_hook</span><span class="p">(</span>
            <span class="n">Video</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">label_cattr</span><span class="o">.</span><span class="n">register_unstructure_hook</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="n">label_cattr</span><span class="o">.</span><span class="n">register_unstructure_hook</span><span class="p">(</span>
            <span class="n">Track</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># Make a converter for the top level skeletons list.</span>
        <span class="n">idx_to_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))}</span>

        <span class="n">skeleton_cattr</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="o">.</span><span class="n">make_cattr</span><span class="p">(</span><span class="n">idx_to_node</span><span class="p">)</span>

        <span class="c1"># Make attr for tracks so that we save as tuples rather than dicts;</span>
        <span class="c1"># this can save a lot of space when there are lots of tracks.</span>
        <span class="n">track_cattr</span> <span class="o">=</span> <span class="n">cattr</span><span class="o">.</span><span class="n">Converter</span><span class="p">(</span><span class="n">unstruct_strat</span><span class="o">=</span><span class="n">cattr</span><span class="o">.</span><span class="n">UnstructureStrategy</span><span class="o">.</span><span class="n">AS_TUPLE</span><span class="p">)</span>

        <span class="c1"># Serialize the skeletons, videos, and labels</span>
        <span class="n">dicts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="n">LABELS_JSON_FILE_VERSION</span><span class="p">,</span>
            <span class="s2">&quot;skeletons&quot;</span><span class="p">:</span> <span class="n">skeleton_cattr</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span><span class="p">),</span>
            <span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="n">cattr</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
            <span class="s2">&quot;videos&quot;</span><span class="p">:</span> <span class="n">Video</span><span class="o">.</span><span class="n">cattr</span><span class="p">()</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">),</span>
            <span class="s2">&quot;tracks&quot;</span><span class="p">:</span> <span class="n">track_cattr</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">),</span>
            <span class="s2">&quot;suggestions&quot;</span><span class="p">:</span> <span class="n">label_cattr</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">suggestions</span><span class="p">),</span>
            <span class="s2">&quot;negative_anchors&quot;</span><span class="p">:</span> <span class="n">label_cattr</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">negative_anchors</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_labels</span><span class="p">:</span>
            <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label_cattr</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dicts</span></div>

<div class="viewcode-block" id="Labels.to_json"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize all labels in the underling list of LabeledFrame(s) to a</span>
<span class="sd">        JSON structured string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The JSON representation of the string.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Unstructure the data into dicts and dump to JSON.</span>
        <span class="k">return</span> <span class="n">json_dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span></div>

<div class="viewcode-block" id="Labels.save_json"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.save_json">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">save_json</span><span class="p">(</span>
        <span class="n">labels</span><span class="p">:</span> <span class="s2">&quot;Labels&quot;</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">save_frame_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">frame_data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;png&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a Labels instance to a JSON format.</span>

<span class="sd">        Args:</span>
<span class="sd">            labels: The labels dataset to save.</span>
<span class="sd">            filename: The filename to save the data to.</span>
<span class="sd">            compress: Whether the data be zip compressed or not? If True,</span>
<span class="sd">                the JSON will be compressed using Python&#39;s shutil.make_archive</span>
<span class="sd">                command into a PKZIP zip file. If compress is True then</span>
<span class="sd">                filename will have a .zip appended to it.</span>
<span class="sd">            save_frame_data: Whether to save the image data for each frame.</span>
<span class="sd">                For each video in the dataset, all frames that have labels</span>
<span class="sd">                will be stored as an imgstore dataset.</span>
<span class="sd">                If save_frame_data is True then compress will be forced to True</span>
<span class="sd">                since the archive must contain both the JSON data and image</span>
<span class="sd">                data stored in ImgStores.</span>
<span class="sd">            frame_data_format: If save_frame_data is True, then this argument</span>
<span class="sd">                is used to set the data format to use when writing frame</span>
<span class="sd">                data to ImgStore objects. Supported formats should be:</span>

<span class="sd">                 * &#39;pgm&#39;,</span>
<span class="sd">                 * &#39;bmp&#39;,</span>
<span class="sd">                 * &#39;ppm&#39;,</span>
<span class="sd">                 * &#39;tif&#39;,</span>
<span class="sd">                 * &#39;png&#39;,</span>
<span class="sd">                 * &#39;jpg&#39;,</span>
<span class="sd">                 * &#39;npy&#39;,</span>
<span class="sd">                 * &#39;mjpeg/avi&#39;,</span>
<span class="sd">                 * &#39;h264/mkv&#39;,</span>
<span class="sd">                 * &#39;avc1/mp4&#39;</span>

<span class="sd">                 Note: &#39;h264/mkv&#39; and &#39;avc1/mp4&#39; require separate installation</span>
<span class="sd">                 of these codecs on your system. They are excluded from SLEAP</span>
<span class="sd">                 because of their GPL license.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Lets make a temporary directory to store the image frame data or pre-compressed json</span>
        <span class="c1"># in case we need it.</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmp_dir</span><span class="p">:</span>

            <span class="c1"># If we are saving frame data along with the datasets. We will replace videos with</span>
            <span class="c1"># new video object that represent video data from just the labeled frames.</span>
            <span class="k">if</span> <span class="n">save_frame_data</span><span class="p">:</span>

                <span class="c1"># Create a set of new Video objects with imgstore backends. One for each</span>
                <span class="c1"># of the videos. We will only include the labeled frames though. We will</span>
                <span class="c1"># then replace each video with this new video</span>
                <span class="n">new_videos</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">save_frame_data_imgstore</span><span class="p">(</span>
                    <span class="n">output_dir</span><span class="o">=</span><span class="n">tmp_dir</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">frame_data_format</span>
                <span class="p">)</span>

                <span class="c1"># Make video paths relative</span>
                <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">new_videos</span><span class="p">:</span>
                    <span class="n">tmp_path</span> <span class="o">=</span> <span class="n">vid</span><span class="o">.</span><span class="n">filename</span>
                    <span class="c1"># Get the parent dir of the YAML file.</span>
                    <span class="c1"># Use &quot;/&quot; since this works on Windows and posix</span>
                    <span class="n">img_store_dir</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
                        <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="c1"># Change to relative path</span>
                    <span class="n">vid</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">img_store_dir</span>

                <span class="c1"># Convert to a dict, not JSON yet, because we need to patch up the videos</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;videos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Video</span><span class="o">.</span><span class="n">cattr</span><span class="p">()</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="n">new_videos</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">compress</span> <span class="ow">or</span> <span class="n">save_frame_data</span><span class="p">:</span>

                <span class="c1"># Ensure that filename ends with .json</span>
                <span class="c1"># shutil will append .zip</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;(\.json)?(\.zip)?$&quot;</span><span class="p">,</span> <span class="s2">&quot;.json&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

                <span class="c1"># Write the json to the tmp directory, we will zip it up with the frame data.</span>
                <span class="n">full_out_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
                <span class="n">json_dumps</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">full_out_filename</span><span class="p">)</span>

                <span class="c1"># Create the archive</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">make_archive</span><span class="p">(</span><span class="n">base_name</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">root_dir</span><span class="o">=</span><span class="n">tmp_dir</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;zip&quot;</span><span class="p">)</span>

            <span class="c1"># If the user doesn&#39;t want to compress, then just write the json to the filename</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">json_dumps</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="Labels.from_json"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.from_json">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">match_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Labels&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create instance of class from data in dictionary.</span>

<span class="sd">        Method is used by other methods that load from JSON.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: Dictionary, deserialized from JSON.</span>
<span class="sd">            match_to: If given, we&#39;ll replace particular objects in the</span>
<span class="sd">                data dictionary with *matching* objects in the match_to</span>
<span class="sd">                :class:`Labels` object. This ensures that the newly</span>
<span class="sd">                instantiated :class:`Labels` can be merged without</span>
<span class="sd">                duplicate matching objects (e.g., :class:`Video` objects ).</span>
<span class="sd">        Returns:</span>
<span class="sd">            A new :class:`Labels` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Parse the json string if needed.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">dicts</span> <span class="o">=</span> <span class="n">json_loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dicts</span> <span class="o">=</span> <span class="n">data</span>

        <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;tracks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dicts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;tracks&quot;</span><span class="p">,</span> <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># don&#39;t break if json doesn&#39;t include tracks</span>

        <span class="c1"># First, deserialize the skeletons, videos, and nodes lists.</span>
        <span class="c1"># The labels reference these so we will need them while deserializing.</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">cattr</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">])</span>

        <span class="n">idx_to_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))}</span>
        <span class="n">skeletons</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="o">.</span><span class="n">make_cattr</span><span class="p">(</span><span class="n">idx_to_node</span><span class="p">)</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span>
            <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;skeletons&quot;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Skeleton</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">videos</span> <span class="o">=</span> <span class="n">Video</span><span class="o">.</span><span class="n">cattr</span><span class="p">()</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;videos&quot;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Video</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># First try unstructuring tuple (newer format)</span>
            <span class="n">track_cattr</span> <span class="o">=</span> <span class="n">cattr</span><span class="o">.</span><span class="n">Converter</span><span class="p">(</span>
                <span class="n">unstruct_strat</span><span class="o">=</span><span class="n">cattr</span><span class="o">.</span><span class="n">UnstructureStrategy</span><span class="o">.</span><span class="n">AS_TUPLE</span>
            <span class="p">)</span>
            <span class="n">tracks</span> <span class="o">=</span> <span class="n">track_cattr</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;tracks&quot;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Track</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># Then try unstructuring dict (older format)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tracks</span> <span class="o">=</span> <span class="n">cattr</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;tracks&quot;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Track</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to load tracks as tuple or dict!&quot;</span><span class="p">)</span>

        <span class="c1"># if we&#39;re given a Labels object to match, use its objects when they match</span>
        <span class="k">if</span> <span class="n">match_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">skeletons</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">old_sk</span> <span class="ow">in</span> <span class="n">match_to</span><span class="o">.</span><span class="n">skeletons</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sk</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">old_sk</span><span class="p">):</span>
                        <span class="c1"># use nodes from matched skeleton</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">match_node</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">old_sk</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
                            <span class="n">node_idx</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                            <span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_node</span>
                        <span class="c1"># use skeleton from match</span>
                        <span class="n">skeletons</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_sk</span>
                        <span class="k">break</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">vid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">videos</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">old_vid</span> <span class="ow">in</span> <span class="n">match_to</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
                    <span class="c1"># compare last three parts of path</span>
                    <span class="k">if</span> <span class="n">vid</span><span class="o">.</span><span class="n">filename</span> <span class="o">==</span> <span class="n">old_vid</span><span class="o">.</span><span class="n">filename</span> <span class="ow">or</span> <span class="n">weak_filename_match</span><span class="p">(</span>
                        <span class="n">vid</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">old_vid</span><span class="o">.</span><span class="n">filename</span>
                    <span class="p">):</span>
                        <span class="c1"># use video from match</span>
                        <span class="n">videos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_vid</span>
                        <span class="k">break</span>

        <span class="n">suggestions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s2">&quot;suggestions&quot;</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
            <span class="n">suggestions_cattr</span> <span class="o">=</span> <span class="n">cattr</span><span class="o">.</span><span class="n">Converter</span><span class="p">()</span>
            <span class="n">suggestions_cattr</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span>
                <span class="n">Video</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">videos</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">suggestions</span> <span class="o">=</span> <span class="n">suggestions_cattr</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span>
                    <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;suggestions&quot;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">SuggestionFrame</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error while loading suggestions (1)&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Convert old suggestion format to new format.</span>
                    <span class="c1"># Old format: {video: list of frame indices}</span>
                    <span class="c1"># New format: [SuggestionFrames]</span>
                    <span class="n">old_suggestions</span> <span class="o">=</span> <span class="n">suggestions_cattr</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span>
                        <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;suggestions&quot;</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Video</span><span class="p">,</span> <span class="n">List</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">video</span> <span class="ow">in</span> <span class="n">old_suggestions</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">suggestions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">SuggestionFrame</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">old_suggestions</span><span class="p">[</span><span class="n">video</span><span class="p">]</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error while loading suggestions (2)&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">pass</span>

        <span class="k">if</span> <span class="s2">&quot;negative_anchors&quot;</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
            <span class="n">negative_anchors_cattr</span> <span class="o">=</span> <span class="n">cattr</span><span class="o">.</span><span class="n">Converter</span><span class="p">()</span>
            <span class="n">negative_anchors_cattr</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span>
                <span class="n">Video</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">videos</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">negative_anchors</span> <span class="o">=</span> <span class="n">negative_anchors_cattr</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span>
                <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;negative_anchors&quot;</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Video</span><span class="p">,</span> <span class="n">List</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">negative_anchors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># If there is actual labels data, get it.</span>
        <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
            <span class="n">label_cattr</span> <span class="o">=</span> <span class="n">make_instance_cattr</span><span class="p">()</span>
            <span class="n">label_cattr</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span>
                <span class="n">Skeleton</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">skeletons</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">label_cattr</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span><span class="n">Video</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">videos</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
            <span class="n">label_cattr</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span>
                <span class="n">Node</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span> <span class="k">else</span> <span class="n">nodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">label_cattr</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span>
                <span class="n">Track</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tracks</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
            <span class="p">)</span>

            <span class="n">labels</span> <span class="o">=</span> <span class="n">label_cattr</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">LabeledFrame</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">labeled_frames</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">videos</span><span class="o">=</span><span class="n">videos</span><span class="p">,</span>
            <span class="n">skeletons</span><span class="o">=</span><span class="n">skeletons</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">suggestions</span><span class="o">=</span><span class="n">suggestions</span><span class="p">,</span>
            <span class="n">negative_anchors</span><span class="o">=</span><span class="n">negative_anchors</span><span class="p">,</span>
            <span class="n">tracks</span><span class="o">=</span><span class="n">tracks</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Labels.load_json"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.load_json">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_json</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">video_callback</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">match_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Labels&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deserialize JSON file as new :class:`Labels` instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Path to JSON file.</span>
<span class="sd">            video_callback: A callback function that which can modify</span>
<span class="sd">                video paths before we try to create the corresponding</span>
<span class="sd">                :class:`Video` objects. Usually you&#39;ll want to pass</span>
<span class="sd">                a callback created by :meth:`make_video_callback`</span>
<span class="sd">                or :meth:`make_gui_video_callback`.</span>
<span class="sd">            match_to: If given, we&#39;ll replace particular objects in the</span>
<span class="sd">                data dictionary with *matching* objects in the match_to</span>
<span class="sd">                :class:`Labels` object. This ensures that the newly</span>
<span class="sd">                instantiated :class:`Labels` can be merged without</span>
<span class="sd">                duplicate matching objects (e.g., :class:`Video` objects ).</span>
<span class="sd">        Returns:</span>
<span class="sd">            A new :class:`Labels` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmp_dir</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Check if the file is a zipfile for not.</span>
        <span class="k">if</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">is_zipfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>

            <span class="c1"># Make a tmpdir, located in the directory that the file exists, to unzip</span>
            <span class="c1"># its contents.</span>
            <span class="n">tmp_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span>
                <span class="sa">f</span><span class="s2">&quot;tmp_{os.getpid()}_{os.path.basename(filename)}&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">):</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">FileExistsError</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># tmp_dir = tempfile.mkdtemp(dir=os.path.dirname(filename))</span>

            <span class="k">try</span><span class="p">:</span>

                <span class="c1"># Register a cleanup routine that deletes the tmpdir on program exit</span>
                <span class="c1"># if something goes wrong. The True is for ignore_errors</span>
                <span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">,</span> <span class="n">tmp_dir</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Uncompress the data into the directory</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">unpack_archive</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">extract_dir</span><span class="o">=</span><span class="n">tmp_dir</span><span class="p">)</span>

                <span class="c1"># We can now open the JSON file, save the zip file and</span>
                <span class="c1"># replace file with the first JSON file we find in the archive.</span>
                <span class="n">json_files</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.json&quot;</span><span class="p">)</span>
                <span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">json_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No JSON file found inside </span><span class="si">{filename}</span><span class="s2">. Are you sure this is a valid sLEAP dataset.&quot;</span>
                    <span class="p">)</span>

                <span class="n">filename</span> <span class="o">=</span> <span class="n">json_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="c1"># If we had problems, delete the temp directory and reraise the exception.</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="c1"># Open and parse the JSON in filename</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>

            <span class="c1"># FIXME: Peek into the json to see if there is version string.</span>
            <span class="c1"># We do this to tell apart old JSON data from leap_dev vs the</span>
            <span class="c1"># newer format for sLEAP.</span>
            <span class="n">json_str</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">dicts</span> <span class="o">=</span> <span class="n">json_loads</span><span class="p">(</span><span class="n">json_str</span><span class="p">)</span>

            <span class="c1"># If we have a version number, then it is new sLEAP format</span>
            <span class="k">if</span> <span class="s2">&quot;version&quot;</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>

                <span class="c1"># Cache the working directory.</span>
                <span class="n">cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
                <span class="c1"># Replace local video paths (for imagestore)</span>
                <span class="k">if</span> <span class="n">tmp_dir</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;videos&quot;</span><span class="p">]:</span>
                        <span class="n">vid</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">][</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="n">tmp_dir</span><span class="p">,</span> <span class="n">vid</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">][</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span>
                        <span class="p">)</span>

                <span class="c1"># Use the callback if given to handle missing videos</span>
                <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">video_callback</span><span class="p">):</span>
                    <span class="n">abort</span> <span class="o">=</span> <span class="n">video_callback</span><span class="p">(</span><span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;videos&quot;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">abort</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">FileNotFoundError</span>

                <span class="c1"># Try to load the labels filename.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">Labels</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">dicts</span><span class="p">,</span> <span class="n">match_to</span><span class="o">=</span><span class="n">match_to</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>

                    <span class="c1"># FIXME: We are going to the labels JSON that has references to</span>
                    <span class="c1"># video files. Lets change directory to the dirname of the json file</span>
                    <span class="c1"># so that relative paths will be from this directory. Maybe</span>
                    <span class="c1"># it is better to feed the dataset dirname all the way down to</span>
                    <span class="c1"># the Video object. This seems like less coupling between classes</span>
                    <span class="c1"># though.</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

                    <span class="c1"># Try again</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">Labels</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">dicts</span><span class="p">,</span> <span class="n">match_to</span><span class="o">=</span><span class="n">match_to</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="c1"># Ok, we give up, where the hell are these videos!</span>
                    <span class="k">raise</span>  <span class="c1"># Re-raise.</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">cwd</span><span class="p">)</span>  <span class="c1"># Make sure to change back if we have problems.</span>

                <span class="k">return</span> <span class="n">labels</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">load_labels_json_old</span><span class="p">(</span><span class="n">data_path</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">parsed_json</span><span class="o">=</span><span class="n">dicts</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">Labels</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span></div>

<div class="viewcode-block" id="Labels.save_hdf5"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.save_hdf5">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">save_hdf5</span><span class="p">(</span>
        <span class="n">labels</span><span class="p">:</span> <span class="s2">&quot;Labels&quot;</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">save_frame_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">frame_data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;png&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize the labels dataset to an HDF5 file.</span>

<span class="sd">        Args:</span>
<span class="sd">            labels: The :class:`Labels` dataset to save</span>
<span class="sd">            filename: The file to serialize the dataset to.</span>
<span class="sd">            append: Whether to append these labeled frames to the file</span>
<span class="sd">                or not.</span>
<span class="sd">            save_frame_data: Whether to save the image frame data for</span>
<span class="sd">                any labeled frame as well. This is useful for uploading</span>
<span class="sd">                the HDF5 for model training when video files are to</span>
<span class="sd">                large to move. This will only save video frames that</span>
<span class="sd">                have some labeled instances.</span>
<span class="sd">            frame_data_format: If save_frame_data is True, then this argument</span>
<span class="sd">                is used to set the data format to use when encoding images</span>
<span class="sd">                saved in HDF5. Supported formats include:</span>

<span class="sd">                * &quot;&quot; for no encoding (ndarray)</span>
<span class="sd">                * &quot;png&quot;</span>
<span class="sd">                * &quot;jpg&quot;</span>
<span class="sd">                * anything else supported by `cv2.imencode`</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Delete the file if it exists, we want to start from scratch since</span>
        <span class="c1"># h5py truncates the file which seems to not actually delete data</span>
        <span class="c1"># from the file. Don&#39;t if we are appending of course.</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">append</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c1"># Serialize all the meta-data to JSON.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">skip_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save_frame_data</span><span class="p">:</span>
            <span class="n">new_videos</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">save_frame_data_hdf5</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">frame_data_format</span><span class="p">)</span>

            <span class="c1"># Replace path to video file with &quot;.&quot; (which indicates that the</span>
            <span class="c1"># video is in the same file as the HDF5 labels dataset).</span>
            <span class="c1"># Otherwise, the video paths will break if the HDF5 labels</span>
            <span class="c1"># dataset file is moved.</span>
            <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">new_videos</span><span class="p">:</span>
                <span class="n">vid</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>

            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;videos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Video</span><span class="o">.</span><span class="n">cattr</span><span class="p">()</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="n">new_videos</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>

            <span class="c1"># Add all the JSON metadata</span>
            <span class="n">meta_group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>

            <span class="c1"># If we are appending and there already exists JSON metadata</span>
            <span class="k">if</span> <span class="n">append</span> <span class="ow">and</span> <span class="s2">&quot;json&quot;</span> <span class="ow">in</span> <span class="n">meta_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>

                <span class="c1"># Otherwise, we need to read the JSON and append to the lists</span>
                <span class="n">old_labels</span> <span class="o">=</span> <span class="n">Labels</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span>
                    <span class="n">meta_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;json&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
                <span class="p">)</span>

                <span class="c1"># A function to join to list but only include new non-dupe entries</span>
                <span class="c1"># from the right hand list.</span>
                <span class="k">def</span> <span class="nf">append_unique</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
                    <span class="n">unique</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">old</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                            <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">old</span><span class="p">]</span>

                        <span class="c1"># If there were no matches, this is a unique object.</span>
                        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># If we have an object that matches, replace the instance with</span>
                            <span class="c1"># the one from the new list. This will will make sure objects</span>
                            <span class="c1"># on the Instances are the same as those in the Labels lists.</span>
                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">match</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                                    <span class="n">old</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

                    <span class="k">return</span> <span class="n">old</span> <span class="o">+</span> <span class="n">unique</span>

                <span class="c1"># Append the lists</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">tracks</span> <span class="o">=</span> <span class="n">append_unique</span><span class="p">(</span><span class="n">old_labels</span><span class="o">.</span><span class="n">tracks</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">tracks</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span> <span class="o">=</span> <span class="n">append_unique</span><span class="p">(</span><span class="n">old_labels</span><span class="o">.</span><span class="n">skeletons</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">videos</span> <span class="o">=</span> <span class="n">append_unique</span><span class="p">(</span><span class="n">old_labels</span><span class="o">.</span><span class="n">videos</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">videos</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">append_unique</span><span class="p">(</span><span class="n">old_labels</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

                <span class="c1"># FIXME: Do something for suggestions and negative_anchors</span>

                <span class="c1"># Get the dict for JSON and save it over the old data</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">skip_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">append</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;videos&quot;</span><span class="p">,</span> <span class="s2">&quot;tracks&quot;</span><span class="p">,</span> <span class="s2">&quot;suggestions&quot;</span><span class="p">):</span>

                    <span class="c1"># Convert for saving in hdf5 dataset</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">(</span><span class="n">json_dumps</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

                    <span class="n">hdf5_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{key}</span><span class="s2">_json&quot;</span>

                    <span class="c1"># Save in its own dataset (e.g., videos_json)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">hdf5_key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,))</span>

                    <span class="c1"># Clear from dict since we don&#39;t want to save this in attribute</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Output the dict to JSON</span>
            <span class="n">meta_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;json&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">(</span><span class="n">json_dumps</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

            <span class="c1"># FIXME: We can probably construct these from attrs fields</span>
            <span class="c1"># We will store Instances and PredcitedInstances in the same</span>
            <span class="c1"># table. instance_type=0 or Instance and instance_type=1 for</span>
            <span class="c1"># PredictedInstance, score will be ignored for Instances.</span>
            <span class="n">instance_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="s2">&quot;instance_id&quot;</span><span class="p">,</span> <span class="s2">&quot;i8&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;instance_type&quot;</span><span class="p">,</span> <span class="s2">&quot;u1&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;frame_id&quot;</span><span class="p">,</span> <span class="s2">&quot;u8&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;skeleton&quot;</span><span class="p">,</span> <span class="s2">&quot;u4&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;track&quot;</span><span class="p">,</span> <span class="s2">&quot;i4&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;from_predicted&quot;</span><span class="p">,</span> <span class="s2">&quot;i8&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="s2">&quot;f4&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;point_id_start&quot;</span><span class="p">,</span> <span class="s2">&quot;u8&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;point_id_end&quot;</span><span class="p">,</span> <span class="s2">&quot;u8&quot;</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">frame_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="s2">&quot;frame_id&quot;</span><span class="p">,</span> <span class="s2">&quot;u8&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;video&quot;</span><span class="p">,</span> <span class="s2">&quot;u4&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;frame_idx&quot;</span><span class="p">,</span> <span class="s2">&quot;u8&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;instance_id_start&quot;</span><span class="p">,</span> <span class="s2">&quot;u8&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;instance_id_end&quot;</span><span class="p">,</span> <span class="s2">&quot;u8&quot;</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="n">num_instances</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">all_instances</span><span class="p">)</span>
            <span class="n">max_skeleton_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Initialize data arrays for serialization</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_instances</span> <span class="o">*</span> <span class="n">max_skeleton_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Point</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">pred_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="n">num_instances</span> <span class="o">*</span> <span class="n">max_skeleton_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PredictedPoint</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span>
            <span class="n">instances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_instances</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">instance_dtype</span><span class="p">)</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">frame_dtype</span><span class="p">)</span>

            <span class="c1"># Pre compute some structures to make serialization faster</span>
            <span class="n">skeleton_to_idx</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">skeleton</span><span class="p">:</span> <span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">skeleton</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span>
            <span class="p">}</span>
            <span class="n">track_to_idx</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">track</span><span class="p">:</span> <span class="n">labels</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">track</span><span class="p">)</span> <span class="k">for</span> <span class="n">track</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">tracks</span>
            <span class="p">}</span>
            <span class="n">track_to_idx</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">video_to_idx</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">video</span><span class="p">:</span> <span class="n">labels</span><span class="o">.</span><span class="n">videos</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">video</span><span class="p">)</span> <span class="k">for</span> <span class="n">video</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">videos</span>
            <span class="p">}</span>
            <span class="n">instance_type_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">Instance</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PredictedInstance</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

            <span class="c1"># Each instance we create will have and index in the dataset, keep track of</span>
            <span class="c1"># these so we can quickly add from_predicted links on a second pass.</span>
            <span class="n">instance_to_idx</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">instances_with_from_predicted</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">instances_from_predicted</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># If we are appending, we need look inside to see what frame, instance, and point</span>
            <span class="c1"># ids we need to start from. This gives us offsets to use.</span>
            <span class="k">if</span> <span class="n">append</span> <span class="ow">and</span> <span class="s2">&quot;points&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">point_id_offset</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pred_point_id_offset</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;pred_points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">instance_id_offset</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;instances&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;instance_id&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">frame_id_offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;frame_id&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point_id_offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">pred_point_id_offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">instance_id_offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">frame_id_offset</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">point_id</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pred_point_id</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">instance_id</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">frame_id</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
                <span class="n">frames</span><span class="p">[</span><span class="n">frame_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">frame_id</span> <span class="o">+</span> <span class="n">frame_id_offset</span><span class="p">,</span>
                    <span class="n">video_to_idx</span><span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">video</span><span class="p">],</span>
                    <span class="n">label</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">,</span>
                    <span class="n">instance_id</span> <span class="o">+</span> <span class="n">instance_id_offset</span><span class="p">,</span>
                    <span class="n">instance_id</span> <span class="o">+</span> <span class="n">instance_id_offset</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">instances</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">label</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>

                    <span class="c1"># Add this instance to our lookup structure we will need for from_predicted</span>
                    <span class="c1"># links</span>
                    <span class="n">instance_to_idx</span><span class="p">[</span><span class="n">instance</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance_id</span>

                    <span class="n">parray</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">get_points_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">instance_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

                    <span class="c1"># Check whether we are working with a PredictedInstance or an Instance.</span>
                    <span class="k">if</span> <span class="n">instance_type</span> <span class="ow">is</span> <span class="n">PredictedInstance</span><span class="p">:</span>
                        <span class="n">score</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">score</span>
                        <span class="n">pid</span> <span class="o">=</span> <span class="n">pred_point_id</span> <span class="o">+</span> <span class="n">pred_point_id_offset</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">pid</span> <span class="o">=</span> <span class="n">point_id</span> <span class="o">+</span> <span class="n">point_id_offset</span>

                        <span class="c1"># Keep track of any from_predicted instance links, we will insert the</span>
                        <span class="c1"># correct instance_id in the dataset after we are done.</span>
                        <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">from_predicted</span><span class="p">:</span>
                            <span class="n">instances_with_from_predicted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instance_id</span><span class="p">)</span>
                            <span class="n">instances_from_predicted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">from_predicted</span><span class="p">)</span>

                    <span class="c1"># Copy all the data</span>
                    <span class="n">instances</span><span class="p">[</span><span class="n">instance_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">instance_id</span> <span class="o">+</span> <span class="n">instance_id_offset</span><span class="p">,</span>
                        <span class="n">instance_type_to_idx</span><span class="p">[</span><span class="n">instance_type</span><span class="p">],</span>
                        <span class="n">frame_id</span><span class="p">,</span>
                        <span class="n">skeleton_to_idx</span><span class="p">[</span><span class="n">instance</span><span class="o">.</span><span class="n">skeleton</span><span class="p">],</span>
                        <span class="n">track_to_idx</span><span class="p">[</span><span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">],</span>
                        <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">score</span><span class="p">,</span>
                        <span class="n">pid</span><span class="p">,</span>
                        <span class="n">pid</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">parray</span><span class="p">),</span>
                    <span class="p">)</span>

                    <span class="c1"># If these are predicted points, copy them to the predicted point array</span>
                    <span class="c1"># otherwise, use the normal point array</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">parray</span><span class="p">)</span> <span class="ow">is</span> <span class="n">PredictedPointArray</span><span class="p">:</span>
                        <span class="n">pred_points</span><span class="p">[</span>
                            <span class="n">pred_point_id</span> <span class="p">:</span> <span class="n">pred_point_id</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">parray</span><span class="p">)</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">parray</span>
                        <span class="n">pred_point_id</span> <span class="o">=</span> <span class="n">pred_point_id</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">parray</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">points</span><span class="p">[</span><span class="n">point_id</span> <span class="p">:</span> <span class="n">point_id</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">parray</span><span class="p">)]</span> <span class="o">=</span> <span class="n">parray</span>
                        <span class="n">point_id</span> <span class="o">=</span> <span class="n">point_id</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">parray</span><span class="p">)</span>

                    <span class="n">instance_id</span> <span class="o">=</span> <span class="n">instance_id</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Add from_predicted links</span>
            <span class="k">for</span> <span class="n">instance_id</span><span class="p">,</span> <span class="n">from_predicted</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">instances_with_from_predicted</span><span class="p">,</span> <span class="n">instances_from_predicted</span>
            <span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">instances</span><span class="p">[</span><span class="n">instance_id</span><span class="p">][</span><span class="s2">&quot;from_predicted&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance_to_idx</span><span class="p">[</span>
                        <span class="n">from_predicted</span>
                    <span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># If we haven&#39;t encountered the from_predicted instance yet then don&#39;t save the link.</span>
                    <span class="c1"># Its possible for a user to create a regular instance from a predicted instance and then</span>
                    <span class="c1"># delete all predicted instances from the file, but in this case I dont think theres any reason</span>
                    <span class="c1"># to remember which predicted instance the regular instance came from.</span>
                    <span class="k">pass</span>

            <span class="c1"># We pre-allocated our points array with max possible size considering the max</span>
            <span class="c1"># skeleton size, drop any unused points.</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">point_id</span><span class="p">]</span>
            <span class="n">pred_points</span> <span class="o">=</span> <span class="n">pred_points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">pred_point_id</span><span class="p">]</span>

            <span class="c1"># Create datasets if we need to</span>
            <span class="k">if</span> <span class="n">append</span> <span class="ow">and</span> <span class="s2">&quot;points&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">][</span><span class="o">-</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">points</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;pred_points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;pred_points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pred_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;pred_points&quot;</span><span class="p">][</span><span class="o">-</span><span class="n">pred_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pred_points</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;instances&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;instances&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">instances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;instances&quot;</span><span class="p">][</span><span class="o">-</span><span class="n">instances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">instances</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">][</span><span class="o">-</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">frames</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                    <span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Point</span><span class="o">.</span><span class="n">dtype</span>
                <span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                    <span class="s2">&quot;pred_points&quot;</span><span class="p">,</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">pred_points</span><span class="p">,</span>
                    <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">PredictedPoint</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                    <span class="s2">&quot;instances&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">instances</span><span class="p">,</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">instance_dtype</span>
                <span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                    <span class="s2">&quot;frames&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">frames</span><span class="p">,</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">frame_dtype</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Labels.load_hdf5"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.load_hdf5">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_hdf5</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">video_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">match_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deserialize HDF5 file as new :class:`Labels` instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Path to HDF5 file.</span>
<span class="sd">            video_callback: A callback function that which can modify</span>
<span class="sd">                video paths before we try to create the corresponding</span>
<span class="sd">                :class:`Video` objects. Usually you&#39;ll want to pass</span>
<span class="sd">                a callback created by :meth:`make_video_callback`</span>
<span class="sd">                or :meth:`make_gui_video_callback`.</span>
<span class="sd">            match_to: If given, we&#39;ll replace particular objects in the</span>
<span class="sd">                data dictionary with *matching* objects in the match_to</span>
<span class="sd">                :class:`Labels` object. This ensures that the newly</span>
<span class="sd">                instantiated :class:`Labels` can be merged without</span>
<span class="sd">                duplicate matching objects (e.g., :class:`Video` objects ).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new :class:`Labels` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>

            <span class="c1"># Extract the Labels JSON metadata and create Labels object with just</span>
            <span class="c1"># this metadata.</span>
            <span class="n">dicts</span> <span class="o">=</span> <span class="n">json_loads</span><span class="p">(</span>
                <span class="n">f</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;json&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;videos&quot;</span><span class="p">,</span> <span class="s2">&quot;tracks&quot;</span><span class="p">,</span> <span class="s2">&quot;suggestions&quot;</span><span class="p">):</span>
                <span class="n">hdf5_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{key}</span><span class="s2">_json&quot;</span>
                <span class="k">if</span> <span class="n">hdf5_key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">json_loads</span><span class="p">(</span><span class="n">item_json</span><span class="p">)</span> <span class="k">for</span> <span class="n">item_json</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="n">hdf5_key</span><span class="p">]]</span>
                    <span class="n">dicts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">items</span>

            <span class="c1"># Video path &quot;.&quot; means the video is saved in same file as labels,</span>
            <span class="c1"># so replace these paths.</span>
            <span class="k">for</span> <span class="n">video_item</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;videos&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">video_item</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">][</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                    <span class="n">video_item</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">][</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>

            <span class="c1"># Use the callback if given to handle missing videos</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">video_callback</span><span class="p">):</span>
                <span class="n">video_callback</span><span class="p">(</span><span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;videos&quot;</span><span class="p">])</span>

            <span class="n">labels</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">dicts</span><span class="p">,</span> <span class="n">match_to</span><span class="o">=</span><span class="n">match_to</span><span class="p">)</span>

            <span class="n">frames_dset</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">][:]</span>
            <span class="n">instances_dset</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;instances&quot;</span><span class="p">][:]</span>
            <span class="n">points_dset</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">][:]</span>
            <span class="n">pred_points_dset</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;pred_points&quot;</span><span class="p">][:]</span>

            <span class="c1"># Rather than instantiate a bunch of Point\PredictedPoint objects, we will</span>
            <span class="c1"># use inplace numpy recarrays. This will save a lot of time and memory</span>
            <span class="c1"># when reading things in.</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">PointArray</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">points_dset</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">points_dset</span><span class="p">))</span>
            <span class="n">pred_points</span> <span class="o">=</span> <span class="n">PredictedPointArray</span><span class="p">(</span>
                <span class="n">buf</span><span class="o">=</span><span class="n">pred_points_dset</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">pred_points_dset</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Extend the tracks list with a None track. We will signify this with a -1 in the</span>
            <span class="c1"># data which will map to last element of tracks</span>
            <span class="n">tracks</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tracks</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="kc">None</span><span class="p">])</span>

            <span class="c1"># A dict to keep track of instances that have a from_predicted link. The key is the</span>
            <span class="c1"># instance and the value is the index of the instance.</span>
            <span class="n">from_predicted_lookup</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># Create the instances</span>
            <span class="n">instances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instances_dset</span><span class="p">:</span>
                <span class="n">track</span> <span class="o">=</span> <span class="n">tracks</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;track&quot;</span><span class="p">]]</span>
                <span class="n">skeleton</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;skeleton&quot;</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;instance_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Instance</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span>
                        <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                        <span class="n">track</span><span class="o">=</span><span class="n">track</span><span class="p">,</span>
                        <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;point_id_start&quot;</span><span class="p">]</span> <span class="p">:</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;point_id_end&quot;</span><span class="p">]],</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># PredictedInstance</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="n">PredictedInstance</span><span class="p">(</span>
                        <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                        <span class="n">track</span><span class="o">=</span><span class="n">track</span><span class="p">,</span>
                        <span class="n">points</span><span class="o">=</span><span class="n">pred_points</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;point_id_start&quot;</span><span class="p">]</span> <span class="p">:</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;point_id_end&quot;</span><span class="p">]],</span>
                        <span class="n">score</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">],</span>
                    <span class="p">)</span>
                <span class="n">instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;from_predicted&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">from_predicted_lookup</span><span class="p">[</span><span class="n">instance</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="s2">&quot;from_predicted&quot;</span><span class="p">]</span>

            <span class="c1"># Make a second pass to add any from_predicted links</span>
            <span class="k">for</span> <span class="n">instance</span><span class="p">,</span> <span class="n">from_predicted_idx</span> <span class="ow">in</span> <span class="n">from_predicted_lookup</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">instance</span><span class="o">.</span><span class="n">from_predicted</span> <span class="o">=</span> <span class="n">instances</span><span class="p">[</span><span class="n">from_predicted_idx</span><span class="p">]</span>

            <span class="c1"># Create the labeled frames</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">LabeledFrame</span><span class="p">(</span>
                    <span class="n">video</span><span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">videos</span><span class="p">[</span><span class="n">frame</span><span class="p">[</span><span class="s2">&quot;video&quot;</span><span class="p">]],</span>
                    <span class="n">frame_idx</span><span class="o">=</span><span class="n">frame</span><span class="p">[</span><span class="s2">&quot;frame_idx&quot;</span><span class="p">],</span>
                    <span class="n">instances</span><span class="o">=</span><span class="n">instances</span><span class="p">[</span>
                        <span class="n">frame</span><span class="p">[</span><span class="s2">&quot;instance_id_start&quot;</span><span class="p">]</span> <span class="p">:</span> <span class="n">frame</span><span class="p">[</span><span class="s2">&quot;instance_id_end&quot;</span><span class="p">]</span>
                    <span class="p">],</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames_dset</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">labels</span><span class="o">.</span><span class="n">labeled_frames</span> <span class="o">=</span> <span class="n">frames</span>

            <span class="c1"># Do the stuff that should happen after we have labeled frames</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">_build_lookup_caches</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="Labels.load_file"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.load_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load file, detecting format from filename.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;.hdf5&quot;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">load_hdf5</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s2">&quot;.json&quot;</span><span class="p">,</span> <span class="s2">&quot;.json.zip&quot;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.mat&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">load_mat</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.csv&quot;</span><span class="p">):</span>
            <span class="c1"># for now, the only csv we support is the DeepLabCut format</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">load_deeplabcut_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot detect filetype for </span><span class="si">{filename}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Labels.save_file"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.save_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">save_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="s2">&quot;Labels&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save file, detecting format from filename.</span>

<span class="sd">        Args:</span>
<span class="sd">            labels: The dataset to save.</span>
<span class="sd">            filename: Path where we&#39;ll save it. We attempt to detect format</span>
<span class="sd">                from the suffix (e.g., &quot;.json&quot;).</span>
<span class="sd">            default_suffix: If we can&#39;t detect valid suffix on filename,</span>
<span class="sd">                we can add default suffix to filename (and use corresponding</span>
<span class="sd">                format). Doesn&#39;t need to have &quot;.&quot; before file extension.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If cannot detect valid filetype.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that all directories for path exist</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Detect filetype and use appropriate save method</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s2">&quot;.json&quot;</span><span class="p">,</span> <span class="s2">&quot;.zip&quot;</span><span class="p">,</span> <span class="s2">&quot;.h5&quot;</span><span class="p">))</span> <span class="ow">and</span> <span class="n">default_suffix</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{default_suffix}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s2">&quot;.json&quot;</span><span class="p">,</span> <span class="s2">&quot;.zip&quot;</span><span class="p">)):</span>
            <span class="n">compress</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.zip&quot;</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">save_json</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.h5&quot;</span><span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">save_hdf5</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot detect filetype for </span><span class="si">{filename}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Labels.save_frame_data_imgstore"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.save_frame_data_imgstore">[docs]</a>    <span class="k">def</span> <span class="nf">save_frame_data_imgstore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="n">all_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write all labeled frames from all videos to imgstore datasets.</span>

<span class="sd">        This only writes frames that have been labeled. Videos without</span>
<span class="sd">        any labeled frames will be included as empty imgstores.</span>

<span class="sd">        Args:</span>
<span class="sd">            output_dir: Path to directory which will contain imgstores.</span>
<span class="sd">            format: The image format to use for the data.</span>
<span class="sd">                Use &quot;png&quot; for lossless, &quot;jpg&quot; for lossy.</span>
<span class="sd">                Other imgstore formats will probably work as well but</span>
<span class="sd">                have not been tested.</span>
<span class="sd">            all_labels: Include any labeled frames, not just the frames</span>
<span class="sd">                we&#39;ll use for training (i.e., those with `Instance` objects ).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of :class:`ImgStoreVideo` objects with the stored</span>
<span class="sd">            frames.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For each label</span>
        <span class="n">imgstore_vids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v_idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">):</span>
            <span class="n">frame_nums</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span>
                <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">lf</span><span class="o">.</span><span class="n">video</span> <span class="ow">and</span> <span class="p">(</span><span class="n">all_labels</span> <span class="ow">or</span> <span class="n">lf</span><span class="o">.</span><span class="n">has_user_instances</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="c1"># Join with &quot;/&quot; instead of os.path.join() since we want</span>
            <span class="c1"># path to work on Windows and Posix systems</span>
            <span class="n">frames_filename</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/frame_data_vid</span><span class="si">{v_idx}</span><span class="s2">&quot;</span>
            <span class="n">vid</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">to_imgstore</span><span class="p">(</span>
                <span class="n">path</span><span class="o">=</span><span class="n">frames_filename</span><span class="p">,</span> <span class="n">frame_numbers</span><span class="o">=</span><span class="n">frame_nums</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span>
            <span class="p">)</span>

            <span class="c1"># Close the video for now</span>
            <span class="n">vid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">imgstore_vids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">imgstore_vids</span></div>

<div class="viewcode-block" id="Labels.save_frame_data_hdf5"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.save_frame_data_hdf5">[docs]</a>    <span class="k">def</span> <span class="nf">save_frame_data_hdf5</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">output_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="n">all_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write labeled frames from all videos to hdf5 file.</span>

<span class="sd">        Args:</span>
<span class="sd">            output_path: Path to HDF5 file.</span>
<span class="sd">            format: The image format to use for the data. Defaults to png.</span>
<span class="sd">            all_labels: Include any labeled frames, not just the frames</span>
<span class="sd">                we&#39;ll use for training (i.e., those with Instances).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of :class:`HDF5Video` objects with the stored frames.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_vids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v_idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">):</span>
            <span class="n">frame_nums</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span>
                <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">lf</span><span class="o">.</span><span class="n">video</span> <span class="ow">and</span> <span class="p">(</span><span class="n">all_labels</span> <span class="ow">or</span> <span class="n">lf</span><span class="o">.</span><span class="n">has_user_instances</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">vid</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">to_hdf5</span><span class="p">(</span>
                <span class="n">path</span><span class="o">=</span><span class="n">output_path</span><span class="p">,</span>
                <span class="n">dataset</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;video</span><span class="si">{v_idx}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
                <span class="n">frame_numbers</span><span class="o">=</span><span class="n">frame_nums</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">vid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">new_vids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_vids</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_unwrap_mat_scalar</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract single value from nested MATLAB file data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">return</span> <span class="n">Labels</span><span class="o">.</span><span class="n">_unwrap_mat_scalar</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_unwrap_mat_array</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract list of values from nested MATLAB file data.&quot;&quot;&quot;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">Labels</span><span class="o">.</span><span class="n">_unwrap_mat_scalar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">c</span>

<div class="viewcode-block" id="Labels.load_mat"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.load_mat">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_mat</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Labels&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Load LEAP MATLAB file as dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Path to csv file.</span>
<span class="sd">        Returns:</span>
<span class="sd">            The :class:`Labels` dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mat_contents</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">box_path</span> <span class="o">=</span> <span class="n">Labels</span><span class="o">.</span><span class="n">_unwrap_mat_scalar</span><span class="p">(</span><span class="n">mat_contents</span><span class="p">[</span><span class="s2">&quot;boxPath&quot;</span><span class="p">])</span>

        <span class="c1"># If the video file isn&#39;t found, try in the same dir as the mat file</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">box_path</span><span class="p">):</span>
            <span class="n">file_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">box_path_name</span> <span class="o">=</span> <span class="n">box_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># assume windows path</span>
            <span class="n">box_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_dir</span><span class="p">,</span> <span class="n">box_path_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">box_path</span><span class="p">):</span>
            <span class="n">vid</span> <span class="o">=</span> <span class="n">Video</span><span class="o">.</span><span class="n">from_hdf5</span><span class="p">(</span>
                <span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">box_path</span><span class="p">,</span> <span class="n">input_format</span><span class="o">=</span><span class="s2">&quot;channels_first&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vid</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO: prompt user to locate video</span>

        <span class="n">nodes_</span> <span class="o">=</span> <span class="n">mat_contents</span><span class="p">[</span><span class="s2">&quot;skeleton&quot;</span><span class="p">][</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
        <span class="n">edges_</span> <span class="o">=</span> <span class="n">mat_contents</span><span class="p">[</span><span class="s2">&quot;skeleton&quot;</span><span class="p">][</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span>
        <span class="n">points_</span> <span class="o">=</span> <span class="n">mat_contents</span><span class="p">[</span><span class="s2">&quot;positions&quot;</span><span class="p">]</span>

        <span class="n">edges_</span> <span class="o">=</span> <span class="n">edges_</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># convert matlab 1-indexing to python 0-indexing</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">Labels</span><span class="o">.</span><span class="n">_unwrap_mat_array</span><span class="p">(</span><span class="n">nodes_</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">Labels</span><span class="o">.</span><span class="n">_unwrap_mat_array</span><span class="p">(</span><span class="n">edges_</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">nodes</span><span class="p">))</span>  <span class="c1"># convert np._str to str</span>

        <span class="n">sk</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">sk</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">sk</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">nodes</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">destination</span><span class="o">=</span><span class="n">nodes</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="n">labeled_frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node_count</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">frame_count</span> <span class="o">=</span> <span class="n">points_</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frame_count</span><span class="p">):</span>
            <span class="n">new_inst</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">sk</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node_idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">points_</span><span class="p">[</span><span class="n">node_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">points_</span><span class="p">[</span><span class="n">node_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">new_inst</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_inst</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                <span class="n">new_frame</span> <span class="o">=</span> <span class="n">LabeledFrame</span><span class="p">(</span><span class="n">video</span><span class="o">=</span><span class="n">vid</span><span class="p">,</span> <span class="n">frame_idx</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                <span class="n">new_frame</span><span class="o">.</span><span class="n">instances</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_inst</span><span class="p">,)</span>
                <span class="n">labeled_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_frame</span><span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">labeled_frames</span><span class="o">=</span><span class="n">labeled_frames</span><span class="p">,</span> <span class="n">videos</span><span class="o">=</span><span class="p">[</span><span class="n">vid</span><span class="p">],</span> <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">sk</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="Labels.load_deeplabcut_csv"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.load_deeplabcut_csv">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_deeplabcut_csv</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Labels&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Load DeepLabCut csv file as dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Path to csv file.</span>
<span class="sd">        Returns:</span>
<span class="sd">            The :class:`Labels` dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># At the moment we don&#39;t need anything from the config file,</span>
        <span class="c1"># but the code to read it is here in case we do in the future.</span>

        <span class="c1"># # Try to find the config file by walking up file path starting at csv file looking for config.csv</span>
        <span class="c1"># last_dir = None</span>
        <span class="c1"># file_dir = os.path.dirname(filename)</span>
        <span class="c1"># config_filename = &quot;&quot;</span>

        <span class="c1"># while file_dir != last_dir:</span>
        <span class="c1">#     last_dir = file_dir</span>
        <span class="c1">#     file_dir = os.path.dirname(file_dir)</span>
        <span class="c1">#     config_filename = os.path.join(file_dir, &#39;config.yaml&#39;)</span>
        <span class="c1">#     if os.path.exists(config_filename):</span>
        <span class="c1">#         break</span>

        <span class="c1"># # If we couldn&#39;t find a config file, give up</span>
        <span class="c1"># if not os.path.exists(config_filename): return</span>

        <span class="c1"># with open(config_filename, &#39;r&#39;) as f:</span>
        <span class="c1">#     config = yaml.load(f, Loader=yaml.SafeLoader)</span>

        <span class="c1"># x1 = config[&#39;x1&#39;]</span>
        <span class="c1"># y1 = config[&#39;y1&#39;]</span>
        <span class="c1"># x2 = config[&#39;x2&#39;]</span>
        <span class="c1"># y2 = config[&#39;y2&#39;]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Create the skeleton from the list of nodes in the csv file</span>
        <span class="c1"># Note that DeepLabCut doesn&#39;t have edges, so these will have to be added by user later</span>
        <span class="n">node_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]]</span>

        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="p">()</span>
        <span class="n">skeleton</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>

        <span class="c1"># Create an imagestore `Video` object from frame images.</span>
        <span class="c1"># This may not be ideal for large projects, since we&#39;re reading in</span>
        <span class="c1"># each image and then writing it out in a new directory.</span>

        <span class="n">img_files</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># get list of all images</span>

        <span class="c1"># the image filenames in the csv may not match where the user has them</span>
        <span class="c1"># so we&#39;ll change the directory to match where the user has the csv</span>
        <span class="k">def</span> <span class="nf">fix_img_path</span><span class="p">(</span><span class="n">img_dir</span><span class="p">,</span> <span class="n">img_filename</span><span class="p">):</span>
            <span class="n">img_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">img_filename</span><span class="p">)</span>
            <span class="n">img_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">img_dir</span><span class="p">,</span> <span class="n">img_filename</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">img_filename</span>

        <span class="n">img_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">img_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">fix_img_path</span><span class="p">(</span><span class="n">img_dir</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="n">img_files</span><span class="p">))</span>

        <span class="c1"># we&#39;ll put the new imgstore in the same directory as the current csv</span>
        <span class="n">imgstore_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;sleap_video&quot;</span><span class="p">)</span>

        <span class="c1"># create the imgstore (or open if it already exists)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">imgstore_name</span><span class="p">):</span>
            <span class="n">video</span> <span class="o">=</span> <span class="n">Video</span><span class="o">.</span><span class="n">from_filename</span><span class="p">(</span><span class="n">imgstore_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">video</span> <span class="o">=</span> <span class="n">Video</span><span class="o">.</span><span class="n">imgstore_from_filenames</span><span class="p">(</span><span class="n">img_files</span><span class="p">,</span> <span class="n">imgstore_name</span><span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="c1"># get points for each node</span>
            <span class="n">instance_points</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)][</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">instance_points</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="c1"># create instance with points (we can assume there&#39;s only one instance per frame)</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">instance_points</span><span class="p">)</span>
            <span class="c1"># create labeledframe and add it to list</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">LabeledFrame</span><span class="p">(</span><span class="n">video</span><span class="o">=</span><span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">instances</span><span class="o">=</span><span class="p">[</span><span class="n">instance</span><span class="p">])</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_coco</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">img_dir</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_missing_gui</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Labels&quot;</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">json_str</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">dicts</span> <span class="o">=</span> <span class="n">json_loads</span><span class="p">(</span><span class="n">json_str</span><span class="p">)</span>

        <span class="c1"># Make skeletons from &quot;categories&quot;</span>
        <span class="n">skeleton_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;categories&quot;</span><span class="p">]:</span>
            <span class="n">skeleton</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">category</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
            <span class="n">skeleton_id</span> <span class="o">=</span> <span class="n">category</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="n">category</span><span class="p">[</span><span class="s2">&quot;keypoints&quot;</span><span class="p">]</span>
            <span class="n">skeleton</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">src_idx</span><span class="p">,</span> <span class="n">dst_idx</span> <span class="ow">in</span> <span class="n">category</span><span class="p">[</span><span class="s2">&quot;skeleton&quot;</span><span class="p">]:</span>
                    <span class="n">skeleton</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node_names</span><span class="p">[</span><span class="n">src_idx</span><span class="p">],</span> <span class="n">node_names</span><span class="p">[</span><span class="n">dst_idx</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># According to the COCO data format specifications[^1], the edges</span>
                <span class="c1"># are supposed to be 1-indexed. But in some of their own</span>
                <span class="c1"># dataset the edges are 1-indexed! So we&#39;ll try.</span>
                <span class="c1"># [1]: http://cocodataset.org/#format-data</span>

                <span class="c1"># Clear any edges we already created using 0-indexing</span>
                <span class="n">skeleton</span><span class="o">.</span><span class="n">clear_edges</span><span class="p">()</span>

                <span class="c1"># Add edges</span>
                <span class="k">for</span> <span class="n">src_idx</span><span class="p">,</span> <span class="n">dst_idx</span> <span class="ow">in</span> <span class="n">category</span><span class="p">[</span><span class="s2">&quot;skeleton&quot;</span><span class="p">]:</span>
                    <span class="n">skeleton</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node_names</span><span class="p">[</span><span class="n">src_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">node_names</span><span class="p">[</span><span class="n">dst_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">skeleton_map</span><span class="p">[</span><span class="n">skeleton_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">skeleton</span>

        <span class="c1"># Make videos from &quot;images&quot;</span>

        <span class="c1"># Remove images that aren&#39;t referenced in the annotations</span>
        <span class="n">img_refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">annotation</span><span class="p">[</span><span class="s2">&quot;image_id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;annotations&quot;</span><span class="p">]]</span>
        <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;images&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">im</span><span class="p">:</span> <span class="n">im</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">img_refs</span><span class="p">,</span> <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;images&quot;</span><span class="p">]))</span>

        <span class="c1"># Key in JSON file should be &quot;file_name&quot;, but sometimes it&#39;s &quot;filename&quot;,</span>
        <span class="c1"># so we have to check both.</span>
        <span class="n">img_filename_key</span> <span class="o">=</span> <span class="s2">&quot;file_name&quot;</span>
        <span class="k">if</span> <span class="n">img_filename_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;images&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">img_filename_key</span> <span class="o">=</span> <span class="s2">&quot;filename&quot;</span>

        <span class="c1"># First add the img_dir to each image filename</span>
        <span class="n">img_paths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">img_dir</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="n">img_filename_key</span><span class="p">])</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;images&quot;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="c1"># See if there are any missing files</span>
        <span class="n">img_missing</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">img_paths</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">img_missing</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">use_missing_gui</span><span class="p">:</span>
                <span class="n">okay</span> <span class="o">=</span> <span class="n">MissingFilesDialog</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">img_missing</span><span class="p">)</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">okay</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Images for COCO dataset could not be found in </span><span class="si">{img_dir}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Update the image paths (with img_dir or user selected path)</span>
        <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;images&quot;</span><span class="p">],</span> <span class="n">img_paths</span><span class="p">):</span>
            <span class="n">image</span><span class="p">[</span><span class="n">img_filename_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>

        <span class="c1"># Create the video objects for the image files</span>
        <span class="n">image_video_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">vid_id_video_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;images&quot;</span><span class="p">]:</span>
            <span class="n">image_id</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
            <span class="n">image_filename</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">img_filename_key</span><span class="p">]</span>

            <span class="c1"># Sometimes images have a vid_id which links multiple images</span>
            <span class="c1"># together as one video. If so, we&#39;ll use that as the video key.</span>
            <span class="c1"># But if there isn&#39;t a vid_id, we&#39;ll treat each images as a</span>
            <span class="c1"># distinct video and use the image id as the video id.</span>
            <span class="n">vid_id</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vid_id&quot;</span><span class="p">,</span> <span class="n">image_id</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">vid_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vid_id_video_map</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">filenames</span><span class="o">=</span><span class="p">[</span><span class="n">image_filename</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">image</span><span class="p">:</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                <span class="n">video</span> <span class="o">=</span> <span class="n">Video</span><span class="o">.</span><span class="n">from_image_filenames</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">vid_id_video_map</span><span class="p">[</span><span class="n">vid_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">video</span>
                <span class="n">frame_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">video</span> <span class="o">=</span> <span class="n">vid_id_video_map</span><span class="p">[</span><span class="n">vid_id</span><span class="p">]</span>
                <span class="n">frame_idx</span> <span class="o">=</span> <span class="n">video</span><span class="o">.</span><span class="n">num_frames</span>
                <span class="n">video</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">filenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image_filename</span><span class="p">)</span>

            <span class="n">image_video_map</span><span class="p">[</span><span class="n">image_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">)</span>

        <span class="c1"># Make instances from &quot;annotations&quot;</span>
        <span class="n">lf_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">track_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="s2">&quot;annotations&quot;</span><span class="p">]:</span>
            <span class="n">skeleton</span> <span class="o">=</span> <span class="n">skeleton_map</span><span class="p">[</span><span class="n">annotation</span><span class="p">[</span><span class="s2">&quot;category_id&quot;</span><span class="p">]]</span>
            <span class="n">image_id</span> <span class="o">=</span> <span class="n">annotation</span><span class="p">[</span><span class="s2">&quot;image_id&quot;</span><span class="p">]</span>
            <span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span> <span class="o">=</span> <span class="n">image_video_map</span><span class="p">[</span><span class="n">image_id</span><span class="p">]</span>
            <span class="n">keypoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">annotation</span><span class="p">[</span><span class="s2">&quot;keypoints&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">track</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;track_id&quot;</span> <span class="ow">in</span> <span class="n">annotation</span><span class="p">:</span>
                <span class="n">track_id</span> <span class="o">=</span> <span class="n">annotation</span><span class="p">[</span><span class="s2">&quot;track_id&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">track_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">track_map</span><span class="p">:</span>
                    <span class="n">track_map</span><span class="p">[</span><span class="n">track_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">Track</span><span class="p">(</span><span class="n">frame_idx</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">track_id</span><span class="p">))</span>
                <span class="n">track</span> <span class="o">=</span> <span class="n">track_map</span><span class="p">[</span><span class="n">track_id</span><span class="p">]</span>

            <span class="n">points</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">any_visible</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keypoints</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># node not labeled for this instance</span>
                    <span class="k">continue</span>

                <span class="n">is_visible</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">any_visible</span> <span class="o">=</span> <span class="n">any_visible</span> <span class="ow">or</span> <span class="n">is_visible</span>
                <span class="n">points</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">is_visible</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">points</span><span class="p">:</span>
                <span class="c1"># If none of the points had 2 has the &quot;visible&quot; flag, we&#39;ll</span>
                <span class="c1"># assume this incorrect and just mark all as visible.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">any_visible</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">point</span><span class="o">.</span><span class="n">visible</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">inst</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">track</span><span class="o">=</span><span class="n">track</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">image_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lf_map</span><span class="p">:</span>
                    <span class="n">lf_map</span><span class="p">[</span><span class="n">image_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">LabeledFrame</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">)</span>

                <span class="n">lf_map</span><span class="p">[</span><span class="n">image_id</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inst</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">labeled_frames</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">lf_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_deepposekit</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">video_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">skeleton_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">video</span> <span class="o">=</span> <span class="n">Video</span><span class="o">.</span><span class="n">from_filename</span><span class="p">(</span><span class="n">video_path</span><span class="p">)</span>

        <span class="n">skeleton_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">skeleton_path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">Skeleton</span><span class="p">()</span>
        <span class="n">skeleton</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">skeleton_data</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">swap</span> <span class="ow">in</span> <span class="n">skeleton_data</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
                <span class="n">skeleton</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="n">lfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pose_matrix</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;pose&quot;</span><span class="p">][:]</span>

            <span class="n">track_count</span><span class="p">,</span> <span class="n">frame_count</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pose_matrix</span><span class="o">.</span><span class="n">shape</span>

            <span class="n">tracks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Track</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Track </span><span class="si">{i}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">frame_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frame_count</span><span class="p">):</span>
                <span class="n">lf_instances</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">track_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">):</span>
                    <span class="n">points_array</span> <span class="o">=</span> <span class="n">pose_matrix</span><span class="p">[</span><span class="n">track_idx</span><span class="p">,</span> <span class="n">frame_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_array</span><span class="p">)):</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="n">points_array</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                        <span class="n">points</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">p</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># TODO: score</span>

                    <span class="n">inst</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span>
                        <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span> <span class="n">track</span><span class="o">=</span><span class="n">tracks</span><span class="p">[</span><span class="n">track_idx</span><span class="p">],</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span>
                    <span class="p">)</span>
                    <span class="n">lf_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span>
                <span class="n">lfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">LabeledFrame</span><span class="p">(</span><span class="n">video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="o">=</span><span class="n">frame_idx</span><span class="p">,</span> <span class="n">instances</span><span class="o">=</span><span class="n">lf_instances</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">labeled_frames</span><span class="o">=</span><span class="n">lfs</span><span class="p">)</span>

<div class="viewcode-block" id="Labels.make_video_callback"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.make_video_callback">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_video_callback</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">search_paths</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a non-GUI callback for finding missing videos.</span>

<span class="sd">        The callback can be used while loading a saved project and</span>
<span class="sd">        allows the user to find videos which have been moved (or have</span>
<span class="sd">        paths from a different system).</span>

<span class="sd">        Args:</span>
<span class="sd">            search_paths: If specified, this is a list of paths where</span>
<span class="sd">                we&#39;ll automatically try to find the missing videos.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The callback function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">search_paths</span> <span class="o">=</span> <span class="n">search_paths</span> <span class="ow">or</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">video_callback</span><span class="p">(</span><span class="n">video_list</span><span class="p">,</span> <span class="n">new_paths</span><span class="o">=</span><span class="n">search_paths</span><span class="p">):</span>
            <span class="c1"># Check each video</span>
            <span class="k">for</span> <span class="n">video_item</span> <span class="ow">in</span> <span class="n">video_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;backend&quot;</span> <span class="ow">in</span> <span class="n">video_item</span> <span class="ow">and</span> <span class="s2">&quot;filename&quot;</span> <span class="ow">in</span> <span class="n">video_item</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">]:</span>
                    <span class="n">current_filename</span> <span class="o">=</span> <span class="n">video_item</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">][</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span>
                    <span class="c1"># check if we can find video</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">current_filename</span><span class="p">):</span>

                        <span class="n">current_basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">current_filename</span><span class="p">)</span>
                        <span class="c1"># handle unix, windows, or mixed paths</span>
                        <span class="k">if</span> <span class="n">current_basename</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">current_basename</span> <span class="o">=</span> <span class="n">current_basename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">current_basename</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">current_basename</span> <span class="o">=</span> <span class="n">current_basename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># First see if we can find the file in another directory,</span>
                        <span class="c1"># and if not, prompt the user to find the file.</span>

                        <span class="c1"># We&#39;ll check in the current working directory, and if the user has</span>
                        <span class="c1"># already found any missing videos, check in the directory of those.</span>
                        <span class="k">for</span> <span class="n">path_dir</span> <span class="ow">in</span> <span class="n">new_paths</span><span class="p">:</span>
                            <span class="n">check_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_dir</span><span class="p">,</span> <span class="n">current_basename</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">check_path</span><span class="p">):</span>
                                <span class="c1"># we found the file in a different directory</span>
                                <span class="n">video_item</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">][</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_path</span>
                                <span class="k">break</span>

        <span class="k">return</span> <span class="n">video_callback</span></div>

<div class="viewcode-block" id="Labels.make_gui_video_callback"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.make_gui_video_callback">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_gui_video_callback</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">search_paths</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a callback with GUI for finding missing videos.</span>

<span class="sd">        The callback can be used while loading a saved project and</span>
<span class="sd">        allows the user to find videos which have been moved (or have</span>
<span class="sd">        paths from a different system).</span>

<span class="sd">        The callback function returns True to signal &quot;abort&quot;.</span>

<span class="sd">        Args:</span>
<span class="sd">            search_paths: If specified, this is a list of paths where</span>
<span class="sd">                we&#39;ll automatically try to find the missing videos.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The callback function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">search_paths</span> <span class="o">=</span> <span class="n">search_paths</span> <span class="ow">or</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">gui_video_callback</span><span class="p">(</span><span class="n">video_list</span><span class="p">,</span> <span class="n">new_paths</span><span class="o">=</span><span class="n">search_paths</span><span class="p">):</span>
            <span class="n">filenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">][</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">video_list</span><span class="p">]</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">pathutils</span><span class="o">.</span><span class="n">list_file_missing</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>

            <span class="c1"># First check for file in search_path directories</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span> <span class="ow">and</span> <span class="n">new_paths</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filenames</span><span class="p">):</span>
                    <span class="n">fixed_path</span> <span class="o">=</span> <span class="n">find_path_using_paths</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">new_paths</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">fixed_path</span> <span class="o">!=</span> <span class="n">filename</span><span class="p">:</span>
                        <span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fixed_path</span>
                        <span class="n">missing</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># If there are still missing paths, prompt user</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
                <span class="n">okay</span> <span class="o">=</span> <span class="n">MissingFilesDialog</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">missing</span><span class="p">)</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">okay</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># True for stop</span>

            <span class="c1"># Replace the video filenames with changes by user</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">video_list</span><span class="p">):</span>
                <span class="n">item</span><span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">][</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">gui_video_callback</span></div>

<div class="viewcode-block" id="Labels.export_training_data"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.export_training_data">[docs]</a>    <span class="k">def</span> <span class="nf">export_training_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_path</span><span class="p">:</span> <span class="n">Text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exports a set of images and points for training with minimal metadata.</span>

<span class="sd">        Args:</span>
<span class="sd">            save_path: Path to HDF5 that training data will be saved to.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The exported HDF5 file will contain no SLEAP-specific metadata or</span>
<span class="sd">            dependencies for serialization. These files cannot be read back in for</span>
<span class="sd">            labeling, but are useful when training on environments where it is hard to</span>
<span class="sd">            install complex dependencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Skeleton</span>
        <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">node_names</span><span class="p">)</span>
        <span class="n">edge_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge_inds</span><span class="p">)</span>

        <span class="c1"># Videos metadata</span>
        <span class="n">video_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">video_datasets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">video_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">video_image_data_format</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">video</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="n">video_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span> <span class="s2">&quot;dataset&quot;</span><span class="p">):</span>
                <span class="n">video_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">video_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">video_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">video_image_data_format</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">input_format</span><span class="p">)</span>

        <span class="n">video_paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">(</span><span class="n">video_paths</span><span class="p">)</span>
        <span class="n">video_datasets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">(</span><span class="n">video_datasets</span><span class="p">)</span>
        <span class="n">video_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">video_shapes</span><span class="p">)</span>
        <span class="n">video_image_data_format</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">(</span><span class="n">video_image_data_format</span><span class="p">)</span>

        <span class="c1"># Main labeling data</span>
        <span class="n">video_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">frame_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peak_samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peak_instances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peak_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peak_tracks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Main labeling data.</span>
        <span class="n">labeled_frames_with_instances</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">lf</span> <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span> <span class="k">if</span> <span class="n">lf</span><span class="o">.</span><span class="n">has_user_instances</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">sample_ind</span><span class="p">,</span> <span class="n">lf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labeled_frames_with_instances</span><span class="p">):</span>

            <span class="c1"># Video index into the videos metadata</span>
            <span class="n">video_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">videos</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lf</span><span class="o">.</span><span class="n">video</span><span class="p">)</span>

            <span class="c1"># Frame index into the original images array</span>
            <span class="n">frame_ind</span> <span class="o">=</span> <span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lf</span><span class="o">.</span><span class="n">video</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span> <span class="s2">&quot;_HDF5Video__original_to_current_frame_idx&quot;</span><span class="p">):</span>
                <span class="n">frame_ind</span> <span class="o">=</span> <span class="n">lf</span><span class="o">.</span><span class="n">video</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">_HDF5Video__original_to_current_frame_idx</span><span class="p">[</span>
                    <span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span>
                <span class="p">]</span>

            <span class="c1"># Actual image data</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">lf</span><span class="o">.</span><span class="n">image</span>

            <span class="n">frame_peaks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">frame_peak_samples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">frame_peak_instances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">frame_peak_channels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">frame_peak_tracks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">instance_ind</span><span class="p">,</span> <span class="n">instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lf</span><span class="o">.</span><span class="n">user_instances</span><span class="p">):</span>
                <span class="n">instance_peaks</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">points_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                <span class="n">frame_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instance_peaks</span><span class="p">)</span>
                <span class="n">frame_peak_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">instance_peaks</span><span class="p">),),</span> <span class="n">sample_ind</span><span class="p">))</span>
                <span class="n">frame_peak_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">instance_peaks</span><span class="p">),),</span> <span class="n">instance_ind</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">frame_peak_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">instance_peaks</span><span class="p">)))</span>
                <span class="n">track_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">track</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">track_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">track</span><span class="p">)</span>
                <span class="n">frame_peak_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">instance_peaks</span><span class="p">),),</span> <span class="n">track_ind</span><span class="p">))</span>

            <span class="c1"># Concatenate into (n_peaks, 2) -&gt; x, y = frame_peaks[i]</span>
            <span class="n">frame_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">frame_peaks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Concatenate metadata</span>
            <span class="n">frame_peak_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">frame_peak_samples</span><span class="p">)</span>
            <span class="n">frame_peak_instances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">frame_peak_instances</span><span class="p">)</span>
            <span class="n">frame_peak_channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">frame_peak_channels</span><span class="p">)</span>
            <span class="n">frame_peak_tracks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">frame_peak_tracks</span><span class="p">)</span>

            <span class="n">video_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">video_ind</span><span class="p">)</span>
            <span class="n">frame_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_ind</span><span class="p">)</span>
            <span class="n">imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="n">peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_peaks</span><span class="p">)</span>
            <span class="n">peak_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_peak_samples</span><span class="p">)</span>
            <span class="n">peak_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_peak_instances</span><span class="p">)</span>
            <span class="n">peak_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_peak_channels</span><span class="p">)</span>
            <span class="n">peak_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak_tracks</span><span class="p">)</span>

        <span class="n">video_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">video_inds</span><span class="p">)</span>
        <span class="n">frame_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frame_inds</span><span class="p">)</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">peak_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">peak_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="n">peak_instances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">peak_instances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="n">peak_channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">peak_channels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="n">peak_tracks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">peak_channels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;skeleton/node_names&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">node_names</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;skeleton/n_nodes&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;skeleton/edges&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">edge_inds</span><span class="p">)</span>

            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;videos/filepath&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">video_paths</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;videos/dataset&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">video_datasets</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;videos/shape&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">video_shapes</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;videos/image_data_format&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">video_image_data_format</span><span class="p">)</span>

            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;imgs&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">imgs</span><span class="p">,</span>
                <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span>
                <span class="n">compression_opts</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;peaks/xy&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">peaks</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;peaks/sample&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">peak_samples</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;peaks/instance&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">peak_instances</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;peaks/channel&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">peak_channels</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;peaks/track&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">peak_tracks</span><span class="p">)</span></div>

<div class="viewcode-block" id="Labels.generate_training_data"><a class="viewcode-back" href="../../../dataset.html#sleap.io.dataset.Labels.generate_training_data">[docs]</a>    <span class="k">def</span> <span class="nf">generate_training_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Generates images and points for training.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of (imgs, points).</span>

<span class="sd">            imgs: Array of shape (n_samples, height, width, channels) containing the</span>
<span class="sd">            image data for all frames with user labels. If frames are of variable size,</span>
<span class="sd">            imgs is a list of length n_samples with elements of shape</span>
<span class="sd">            (height, width, channels).</span>

<span class="sd">            points: List of length n_samples with elements of shape</span>
<span class="sd">            (n_instances, n_nodes, 2), containing all user labeled instances in the</span>
<span class="sd">            frame, with NaN-padded xy coordinates for each visible body part.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">imgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_frames</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lf</span><span class="o">.</span><span class="n">has_user_instances</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lf</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">inst</span><span class="o">.</span><span class="n">points_array</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">lf</span><span class="o">.</span><span class="n">user_instances</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Try to stack all images into a single 4D array.</span>
        <span class="n">first_shape</span> <span class="o">=</span> <span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">can_stack</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">first_shape</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">imgs</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">can_stack</span><span class="p">:</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">imgs</span><span class="p">,</span> <span class="n">points</span></div></div>


<span class="k">def</span> <span class="nf">find_path_using_paths</span><span class="p">(</span><span class="n">missing_path</span><span class="p">,</span> <span class="n">search_paths</span><span class="p">):</span>

    <span class="c1"># Get basename (filename with directories) using current os path format</span>
    <span class="n">current_basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">missing_path</span><span class="p">)</span>

    <span class="c1"># Handle unix, windows, or mixed paths</span>
    <span class="k">if</span> <span class="n">current_basename</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">current_basename</span> <span class="o">=</span> <span class="n">current_basename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">current_basename</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">current_basename</span> <span class="o">=</span> <span class="n">current_basename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Look for file with that name in each of the search path directories</span>
    <span class="k">for</span> <span class="n">path_dir</span> <span class="ow">in</span> <span class="n">search_paths</span><span class="p">:</span>
        <span class="n">check_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_dir</span><span class="p">,</span> <span class="n">current_basename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">check_path</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">check_path</span>

    <span class="k">return</span> <span class="n">missing_path</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">SLEAP</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial-part2.html">Tutorial, Part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Feature Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Murthy Lab @ Princeton.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>